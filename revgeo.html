<!doctype html>
<html lang="ko">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="color-scheme" content="light dark">
  <meta name="theme-color" content="#f9fafb" media="(prefers-color-scheme: light)">
  <meta name="theme-color" content="#0f172a" media="(prefers-color-scheme: dark)">
  <link rel="preconnect" href="https://nominatim.openstreetmap.org">
  <link rel="icon" type="image/svg+xml"
    href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'%3E%3Cpath fill='%233b82f6' d='M256,0C153.755,0,70.573,83.182,70.573,185.426c0,126.888,165.939,313.167,173.004,321.035 c6.636,7.391,18.222,7.378,24.849,0c7.065-7.868,173.004-194.147,173.004-321.035C441.427,83.182,358.245,0,256,0z M256,278.719c-51.442,0-93.292-41.851-93.292-93.292c0-51.441,41.851-93.292,93.292-93.292 c51.441,0,93.292,41.851,93.292,93.292C349.292,236.868,307.441,278.719,256,278.719z'/%3E%3C/svg%3E">
  <link rel="apple-touch-icon" href="apple-touch-icon.png">
  <title>SRG 데이터 역지오코딩 도구</title>
  <style>
    @layer reset, theme, layout, components, utilities;

    @layer reset {

      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }

      html,
      body {
        margin: 0;
        min-height: 100dvh;
      }

      fieldset {
        margin: 0;
        padding: 0;
        border: 0;
      }
    }

    @layer theme {
      :root {
        color-scheme: light dark;
        --card: light-dark(oklch(98% 0.01 240), oklch(15% 0.04 250));
        --line: light-dark(oklch(88% 0.02 240), oklch(25% 0.04 250));
        --muted: light-dark(oklch(55% 0.05 240), oklch(70% 0.05 240));
        --fg: light-dark(oklch(15% 0.03 240), oklch(92% 0.01 240));
        --accent: light-dark(oklch(60% 0.2 260), oklch(70% 0.15 250));
        --accent-2: light-dark(oklch(60% 0.18 150), oklch(75% 0.15 150));
        --warn: light-dark(#d97706, #f59e0b);
        --err: light-dark(#dc2626, #ef4444);
        --shadow: light-dark(0 10px 20px rgba(15, 23, 42, .08), 0 10px 20px rgba(0, 0, 0, .25));
        --shadow-border: light-dark(rgba(148, 163, 184, .7), rgba(15, 23, 42, .8));
        --font-mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        interpolate-size: allow-keywords;
      }

      @property --value {
        syntax: '<number>';
        inherits: true;
        initial-value: 0;
      }

      html {
        scrollbar-color: var(--muted) transparent;
        scrollbar-width: thin;
      }

      body {
        font-family: system-ui, BlinkMacSystemFont, "Segoe UI", "Noto Sans KR", sans-serif;
        font-variant-numeric: tabular-nums;
        background: radial-gradient(circle at top left, light-dark(oklch(95% 0.01 240), oklch(20% 0.04 250)), light-dark(oklch(99% 0 0), oklch(10% 0.02 260)));
        color: var(--fg);
        accent-color: var(--accent);
        padding: 16px;
        display: flex;
        flex-direction: column;
        gap: 12px;
        align-items: center;
      }

      :root::selection {
        background-color: oklch(70% 0.15 250);
        color: white;
      }

      @media (prefers-color-scheme: light) {
        :root::selection {
          background-color: oklch(60% 0.2 260);
        }
      }
    }

    @layer layout {

      main,
      header,
      footer {
        width: min(1500px, 100%);
      }

      header {
        padding: 16px 20px;
        border-radius: 14px;
        background: radial-gradient(circle at top left, light-dark(oklch(90% 0.05 250 / 0.8), oklch(30% 0.1 260 / 0.35)), light-dark(oklch(98% 0 0 / 0.98), oklch(15% 0.04 250 / 0.96)));
        border: 1px solid var(--line);
        box-shadow: var(--shadow), 0 0 0 1px var(--shadow-border);
        display: flex;
        align-items: center;
        gap: 16px;

        h1 {
          margin: 0;
          font-size: 18px;
          letter-spacing: -.02em;
          text-wrap: balance;
          line-height: 1.3;
        }

        p {
          margin-block-start: 4px;
          font-size: 13px;
          color: var(--muted);
          line-height: 1.4;
        }

        code {
          font-family: var(--font-mono);
          font-size: 12px;
          padding: 1px 4px;
          border-radius: 4px;
          background: light-dark(rgba(243, 244, 246, .9), rgba(15, 23, 42, .7));
          border: 1px solid light-dark(rgba(148, 163, 184, .8), rgba(148, 163, 184, .7));
        }
      }

      main {
        display: grid;
        grid-template-columns: minmax(380px, 520px) 1fr;
        gap: 12px;
        align-items: stretch;

        @media (max-width: 900px) {
          grid-template-columns: minmax(0, 1fr);
        }
      }

      footer {
        font-size: 11px;
        color: var(--muted);
        text-align: right;

        code {
          font-family: var(--font-mono);
          font-size: 11px;
        }
      }
    }

    @layer components {
      section {
        position: relative;
        overflow: hidden;

        &::before {
          content: "";
          position: absolute;
          inset: -60px;
          background:
            radial-gradient(circle at top left, oklch(70% 0.2 260 / 0.16), transparent 60%),
            radial-gradient(circle at bottom right, oklch(70% 0.2 150 / 0.12), transparent 60%);
          opacity: .9;
          mix-blend-mode: screen;
          pointer-events: none;

          @media (prefers-color-scheme: light) {
            opacity: .7;
            mix-blend-mode: normal;
          }
        }
      }

      .card {
        background: var(--card);
        border: 1px solid var(--line);
        border-radius: 14px;
        padding: 14px;
        box-shadow: var(--shadow), 0 0 0 1px var(--shadow-border);
        display: flex;
        flex-direction: column;
      }

      .row {
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;

        &.row-progress {
          align-items: flex-end;
          margin-block-start: 8px;
        }
      }

      .sp {
        flex: 1;
      }

      .caps {
        font-variant: all-small-caps;
        letter-spacing: .4px;
        color: var(--muted);
      }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        white-space: nowrap;
        border: 0;
        clip-path: inset(50%);
      }

      label {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-size: 13px;
        color: var(--fg);
        user-select: none;
      }

      input[type="file"],
      button {
        border-radius: 10px;
        border: 1px solid var(--line);
        background: transparent;
        color: var(--fg);
        padding: 10px 12px;
        user-select: none;
        caret-color: var(--accent);

        &:active {
          transform: translateY(1px);
        }
      }

      input[type="file"] {
        padding: 6px;

        &::file-selector-button {
          border-radius: 6px;
          border: 1px solid var(--line);
          background: light-dark(rgba(0, 0, 0, 0.05), rgba(255, 255, 255, 0.06));
          color: var(--fg);
          padding: 6px 10px;
          margin-inline-end: 10px;
          cursor: pointer;
          transition: background .2s;

          &:hover {
            background: light-dark(rgba(0, 0, 0, 0.1), rgba(255, 255, 255, 0.1));
          }
        }
      }

      button {
        cursor: pointer;
        background: linear-gradient(180deg, rgba(255, 255, 255, .06), rgba(255, 255, 255, 0));
        transition: transform .08s ease, filter .15s ease;

        &:disabled {
          opacity: .5;
          cursor: default;
          filter: grayscale(.6);
        }

        &:not(:disabled):hover {
          transform: translateY(-1px);
          filter: brightness(1.1);
        }
      }

      button:focus-visible,
      input[type="file"]:focus-visible,
      textarea:focus-visible {
        outline: 2px solid var(--accent);
        outline-offset: 2px;
      }

      textarea {
        width: 100%;
        min-height: 110px;
        border-radius: 10px;
        border: 1px solid var(--line);
        background: light-dark(rgba(249, 250, 251, .96), rgba(15, 23, 42, .8));
        color: var(--fg);
        padding: 8px;
        font-family: var(--font-mono);
        font-size: 12px;
        field-sizing: content;
        max-block-size: 400px;
        caret-color: var(--accent);
        transition: height 0.3s ease, min-height 0.3s ease;

        &::placeholder {
          color: rgba(156, 163, 175, .8);
        }
      }

      .progress-bar {
        --value: 0;
        width: 100%;
        height: 8px;
        border-radius: 999px;
        border: 1px solid var(--line);
        background-color: rgba(15, 23, 42, .85);
        overflow: hidden;
        position: relative;
        transition: --value 0.3s ease-out;

        &::before {
          content: "";
          position: absolute;
          inset: 0;
          transform-origin: left;
          transform: scaleX(calc(var(--value) / 100));
          background: linear-gradient(90deg, var(--accent), var(--accent-2));
          border-radius: inherit;
        }
      }

      .status {
        display: block;
        margin-block-start: 8px;
        font-size: 13px;
        color: var(--muted);
        min-height: 1.2em;

        &.err {
          color: var(--err);
        }

        &.warn {
          color: var(--warn);
        }
      }

      .counts {
        font-size: 12px;
        color: var(--muted);

        strong {
          color: var(--fg);
        }
      }

      .table-wrap {
        flex: 1;
        min-height: 0;
        max-height: min(500px, 60vh);
        overflow: auto;
        content-visibility: auto;
        contain-intrinsic-size: 0 460px;
        border-radius: 12px;
        border: 1px solid var(--line);
        background: light-dark(rgba(249, 250, 251, .96), rgba(15, 23, 42, .85));
        box-shadow: var(--shadow), 0 0 0 1px var(--shadow-border);
        scrollbar-gutter: stable;
        overscroll-behavior: contain;

        &:focus-visible {
          outline: 2px solid var(--accent);
          outline-offset: 3px;
        }

        &[data-state="idle"]:not(:has(tbody tr))::after {
          content: "아직 결과가 없습니다. 좌표를 추출하고 조회를 시작해 주세요.";
          display: block;
          padding: 24px;
          text-align: center;
          color: var(--muted);
          font-size: 13px;
          pointer-events: none;
        }
      }

      table {
        border-collapse: collapse;
        width: 100%;
        font-size: 12px;
        min-width: 760px;
      }

      caption {
        text-align: left;
        padding: 8px 10px;
        font-size: 11px;
        color: var(--muted);
      }

      thead th {
        position: sticky;
        top: 0;
        z-index: 1;
        text-align: left;
        padding: 10px 12px;
        border-bottom: 1px solid var(--line);
        background-color: color-mix(in srgb, var(--card), transparent 20%);
        backdrop-filter: blur(8px);
        white-space: nowrap;
        text-overflow: ellipsis;
        overflow: hidden;
        animation: scroll-shadow linear both;
        animation-timeline: scroll();
        animation-range: 0px 20px;
      }

      @keyframes scroll-shadow {
        to {
          box-shadow: 0 4px 10px -2px rgba(0, 0, 0, 0.1);
          border-bottom-color: transparent;
        }
      }

      tbody td {
        padding: 10px 12px;
        vertical-align: top;
        overflow-wrap: break-word;
        text-wrap: pretty;
      }

      tbody th {
        vertical-align: top;
        padding: 10px 12px;
        text-align: center;
        font-weight: normal;
        color: var(--muted);
      }

      tbody td:nth-child(3) {
        width: min-content;
        min-width: 85px;
        white-space: normal;
        font-family: var(--font-mono);
        font-size: 11.5px;
        line-height: 1.35;
        color: var(--muted);
      }

      tbody tr {
        border-bottom: 1px dashed var(--line);
        transition: opacity 0.3s ease-out, transform 0.3s ease-out;
        opacity: 1;
        transform: translateY(0);

        @starting-style {
          opacity: 0;
          transform: translateY(10px);
        }

        &:last-child {
          border-bottom: 0;
        }

        &:nth-child(even) {
          background: oklch(from var(--card) calc(l - 0.015) c h);
        }
      }
    }

    @layer utilities {
      #results-title {
        margin: 0 0 8px;
      }

      .tags-cell {
        font-family: var(--font-mono);
        font-size: 12.5px;
        color: var(--muted);
      }

      .nowrap {
        white-space: nowrap;
      }

      .ellipsis {
        max-width: 22ch;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        display: inline-block;
      }

      a {
        color: var(--accent);
        text-decoration: none;
        text-decoration-thickness: 1px;
        text-underline-offset: 2px;
        text-underline-position: from-font;

        &:hover {
          text-decoration: underline;
        }

        &:focus-visible {
          outline: 2px solid var(--accent-2);
          outline-offset: 2px;
          border-radius: 3px;
        }
      }
    }
  </style>
</head>

<body>
  <header>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" width="42" height="42" fill="currentColor"
      aria-hidden="true" style="flex-shrink: 0;">
      <path
        d="M256,0C153.755,0,70.573,83.182,70.573,185.426c0,126.888,165.939,313.167,173.004,321.035 c6.636,7.391,18.222,7.378,24.849,0c7.065-7.868,173.004-194.147,173.004-321.035C441.427,83.182,358.245,0,256,0z M256,278.719c-51.442,0-93.292-41.851-93.292-93.292c0-51.441,41.851-93.292,93.292-93.292 c51.441,0,93.292,41.851,93.292,93.292C349.292,236.868,307.441,278.719,256,278.719z" />
    </svg>
    <div>
      <h1>SRG 데이터 역지오코딩 도구</h1>
      <p><strong>SRG의 random_data.txt에서</strong> 좌표를 추출해 Nominatim(OpenStreetMap) API를 호출하여 주소를 구합니다.</p>
    </div>
  </header>
  <main>
    <section class="card" aria-labelledby="controls-title">
      <h2 id="controls-title" class="sr-only">파일 업로드 및 실행</h2>
      <search>
        <form class="row">
          <fieldset class="row">
            <legend class="sr-only">파일 업로드 및 실행</legend>
            <label for="file">random_data.txt</label>
            <input type="file" id="file" accept=".txt">
            <div class="row">
              <button type="button" id="parse" enterkeyhint="done">좌표 추출</button>
              <button type="button" id="start" enterkeyhint="go" disabled>조회 시작</button>
              <button type="button" id="pause" disabled>일시정지</button>
              <button type="button" id="resume" disabled>재개</button>
              <button type="button" id="stop" disabled>중지</button>
              <button type="button" id="export" disabled>CSV 내보내기</button>
            </div>
          </fieldset>
        </form>
      </search>
      <div>
        <label for="coords">
          <span class="caps">추출된 좌표 (lat,lon)</span>
        </label>
        <textarea id="coords" readonly spellcheck="false" placeholder="random_data.txt에서 추출된 좌표가 이곳에 표시됩니다."></textarea>
      </div>
      <div class="row row-progress">
        <div class="sp">
          <div class="caps" id="prog-label">진행 상황 0%</div>
          <div id="prog" class="progress-bar" role="progressbar" aria-labelledby="prog-label" aria-valuemin="0"
            aria-valuemax="100" aria-valuenow="0">
          </div>
        </div>
        <output class="counts" id="counts">
          총 <strong>0</strong>건 중
          <strong>0</strong>건 완료,
          <strong>0</strong>건 실패,
          <strong>0</strong>건 미처리
        </output>
      </div>
      <output id="status" class="status" role="status" aria-live="polite" aria-atomic="true"></output>
    </section>
    <section class="card" aria-labelledby="results-title">
      <h2 id="results-title" class="caps">결과 표</h2>
      <div class="table-wrap" role="region" aria-label="역지오코딩 결과" tabindex="0" data-state="idle">
        <table id="tbl">
          <caption>각 좌표별로 분류, 주소, 행정구역, 지도 링크를 표시합니다.</caption>
          <thead>
            <tr>
              <th scope="col">구분</th>
              <th scope="col">순번</th>
              <th scope="col">좌표 (위도,경도)</th>
              <th scope="col">시·도</th>
              <th scope="col">시·군·구</th>
              <th scope="col">읍·면·동·리</th>
              <th scope="col">지물 태그</th>
              <th scope="col">전체주소</th>
              <th scope="col">지도링크</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>
  </main>
  <footer>
    <p>서비스 품질을 위해 너무 빠른 요청은 제한될 수 있습니다. 공용 API 사용 정책을 존중해 주세요. (<code>nominatim.openstreetmap.org</code> 1req/sec 권장) •
      실패 시 자동으로 짧은 대기 후 재시도합니다.</p>
  </footer>
  <noscript>이 도구는 자바스크립트가 필요합니다.</noscript>
  <script type="module">
    const CONFIG = {
      MAX_RETRY: 3,
      REQUEST_TIMEOUT_MS: 10000,
      RATE_LIMIT_DELAY_MS: 1000,
      REVERSE_ZOOM: 14,
      SPECIAL_CITIES: ['서울', '부산', '대구', '인천', '광주', '대전', '울산', '세종'],
      MAP_TEMPLATES: {
        Google: 'https://www.google.com/maps?q=${latStr},${lonStr}',
        OSM: 'https://www.openstreetmap.org/search?query=${osmQuery}&zoom=${zoom}#map=${zoom}/${latStr}/${lonStr}',
        Naver: 'https://map.naver.com/?lng=${lonStr}&lat=${latStr}&title=${title}',
        Kakao: 'https://map.kakao.com/link/map/${title},${latStr},${lonStr}',
      }
    };
    const nf = new Intl.NumberFormat('ko-KR');
    const listFormatter = new Intl.ListFormat('ko', { style: 'narrow', type: 'unit' });
    const els = {
      file: document.getElementById('file'),
      parse: document.getElementById('parse'),
      start: document.getElementById('start'),
      pause: document.getElementById('pause'),
      resume: document.getElementById('resume'),
      stop: document.getElementById('stop'),
      exportBtn: document.getElementById('export'),
      status: document.getElementById('status'),
      counts: document.getElementById('counts'),
      prog: document.getElementById('prog'),
      progLabel: document.getElementById('prog-label'),
      tbody: document.querySelector('#tbl tbody'),
      coords: document.getElementById('coords'),
      tableWrap: document.querySelector('.table-wrap'),
    };
    const BASE_COLUMNS = [
      '구분', '순번', '좌표 (위도,경도)', '시·도', '시·군·구', '읍·면·동·리', '지물 태그', '전체주소',
    ];
    const MAP_PROVIDERS = [
      { key: 'Google', header: '지도링크(Google)' },
      { key: 'OSM', header: '지도링크(OSM)' },
      { key: 'Naver', header: '지도링크(Naver)' },
      { key: 'Kakao', header: '지도링크(Kakao)' },
    ];
    let records = [];
    let results = [];
    let stopFlag = false;
    let paused = false;
    let running = false;
    let controller = null;
    let currentIndex = 0;
    let resumeHandler = null;
    let inFlight = false;
    let processedCount = 0;
    let successCount = 0;
    function setStatus(msg, type = 'info') {
      const el = els.status;
      el.textContent = msg;
      el.classList.remove('err', 'warn');
      if (type === 'error') el.classList.add('err');
      else if (type === 'warn') el.classList.add('warn');
    }
    function setTableState(state) {
      els.tableWrap.setAttribute('data-state', state);
    }
    function resetProcessingState(total) {
      results = [];
      currentIndex = 0;
      paused = false;
      processedCount = 0;
      successCount = 0;
      clearTable();
      setProgress(0, total);
      updateCounts();
    }
    function setControlsIdle(message, type = 'info') {
      running = false;
      stopFlag = false;
      setStatus(message, type);
      els.start.disabled = false;
      els.pause.disabled = true;
      els.resume.disabled = true;
      els.stop.disabled = true;
      setTableState('idle');
    }
    function updateCounts() {
      const total = records.length;
      const processed = processedCount;
      const success = successCount;
      const fail = Math.max(0, processed - success);
      const remaining = Math.max(0, total - processed);
      els.counts.innerHTML =
        `총 <strong>${nf.format(total)}</strong>건 중 ` +
        `<strong>${nf.format(success)}</strong>건 완료, ` +
        `<strong>${nf.format(fail)}</strong>건 실패, ` +
        `<strong>${nf.format(remaining)}</strong>건 미처리`;
      els.exportBtn.disabled = processed === 0;
    }
    function setProgress(done, total) {
      const pct = total ? Math.round((done / total) * 100) : 0;
      els.prog.style.setProperty("--value", pct);
      els.prog.setAttribute("aria-valuenow", String(pct));
      els.progLabel.textContent = `진행 상황 ${pct}%`;
    }
    function clearTable() {
      while (els.tbody.firstChild) els.tbody.removeChild(els.tbody.firstChild);
    }
    function isKR(lat, lon) {
      return lat >= 32 && lat <= 39 && lon >= 124 && lon <= 132;
    }
    function mapLinks(lat, lon) {
      const latStr = String(lat);
      const lonStr = String(lon);
      const zoom = 16;
      const osmQuery = encodeURIComponent(`${latStr},${lonStr}`);
      const title = encodeURIComponent(`${latStr} ${lonStr}`);
      const replaceTemplate = (tmpl) => {
        return tmpl
          .replace(/\$\{latStr\}/g, latStr)
          .replace(/\$\{lonStr\}/g, lonStr)
          .replace(/\$\{zoom\}/g, zoom)
          .replace(/\$\{osmQuery\}/g, osmQuery)
          .replace(/\$\{title\}/g, title);
      };
      return MAP_PROVIDERS.map(p => ({
        label: p.key,
        url: replaceTemplate(CONFIG.MAP_TEMPLATES[p.key] || ''),
      }));
    }
    function sleep(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }
    async function yieldToMain() {
      if ('scheduler' in window && 'yield' in window.scheduler) {
        await window.scheduler.yield();
      } else {
        await new Promise(r => setTimeout(r, 0));
      }
    }
    async function fetchReverseWithRetry(lat, lon, signal) {
      const buildUrl = () => {
        const url = new URL('https://nominatim.openstreetmap.org/reverse');
        url.searchParams.set('format', 'jsonv2');
        url.searchParams.set('lat', String(lat));
        url.searchParams.set('lon', String(lon));
        url.searchParams.set('zoom', String(CONFIG.REVERSE_ZOOM));
        url.searchParams.set('addressdetails', '1');
        url.searchParams.set('accept-language', 'ko');
        return url;
      };
      let attempt = 0;
      while (attempt < CONFIG.MAX_RETRY) {
        attempt++;
        const timeoutSignal = AbortSignal.timeout(CONFIG.REQUEST_TIMEOUT_MS);
        const combinedSignal = signal ? AbortSignal.any([signal, timeoutSignal]) : timeoutSignal;
        const res = await fetch(buildUrl(), {
          headers: { 'Accept': 'application/json' },
          signal: combinedSignal,
        });
        if (res.ok) return res.json();
        if (res.status === 429 || res.status >= 500) {
          await sleep(CONFIG.RATE_LIMIT_DELAY_MS * attempt);
          continue;
        }
        const text = await res.text();
        throw new Error(`HTTP ${res.status}: ${text.slice(0, 200)}`);
      }
      throw new Error('재시도 후 실패');
    }
    function getKoreanAdminArea(a) {
      let sido = a.province || a.state || a.region || '';
      let tmpCity = a.city || a.county || a.municipality || '';
      let tmpGu = a.district || a.borough || a.suburb || '';
      let sigungu = '';
      const isSpecialCity = CONFIG.SPECIAL_CITIES.some(c => tmpCity.includes(c));
      if (!sido && isSpecialCity) {
        sido = tmpCity;
        sigungu = tmpGu;
      } else {
        sigungu = tmpCity;
        if (tmpCity && tmpGu && tmpCity !== tmpGu) {
          if (!sigungu.includes(tmpGu)) {
            sigungu += ' ' + tmpGu;
          }
        } else if (!sigungu) {
          sigungu = tmpGu;
        }
      }
      const emd = a.town || a.township || a.neighbourhood || a.city_district || '';
      const ri = a.village || a.hamlet || '';
      const eupmyeon = [emd, ri].filter(Boolean).join(' ');
      return { sido, sigungu, eupmyeon };
    }
    function getFeatureTag(a, data) {
      if (!data || typeof data !== 'object') return '';
      const parts = [];
      const name = data.name || a.attraction || a.building;
      const addType = data.addresstype;
      const category = data.category;
      if (name) parts.push(name);
      if (addType && addType !== name) parts.push(addType);
      else if (category && category !== name) parts.push(category);
      if (parts.length > 0) {
        return listFormatter.format(parts);
      }
      return '';
    }
    function toKoreanAddressParts(a, data) {
      const countryCode = (a.country_code || '').toLowerCase();
      const isKR = countryCode === 'kr' || a.country === '대한민국';
      let result = { sido: '', sigungu: '', eupmyeon: '', tag: '' };
      if (isKR) {
        const admin = getKoreanAdminArea(a);
        result.sido = admin.sido;
        result.sigungu = admin.sigungu;
        result.eupmyeon = admin.eupmyeon;
      } else {
        result.sido = a.state || a.region || a.province || a.county || a.city || '';
        result.sigungu = a.city || a.town || a.county || a.district || a.municipality || a.region || '';
        result.eupmyeon = a.village || a.suburb || a.neighbourhood || a.quarter || a.hamlet || a.city_district || a.township || a.residential || '';
      }
      result.tag = getFeatureTag(a, data);
      return result;
    }
    function extractCoordinates(text) {
      const out = [];
      const push = (lat, lon, setLabel) => {
        if (
          Number.isFinite(lat) && Number.isFinite(lon) &&
          Math.abs(lat) <= 90 && Math.abs(lon) <= 180
        ) {
          out.push({ lat, lon, setLabel });
        }
      };
      const krRe = /대한민국\s*위경도\s*[:：]\s*([+-]?\d+(?:\.\d+)?)\s*[,，]\s*([+-]?\d+(?:\.\d+)?)/gi;
      const worldRe = /세계\s*위경도\s*[:：]\s*([+-]?\d+(?:\.\d+)?)\s*[,，]\s*([+-]?\d+(?:\.\d+)?)/gi;
      const pairRe = /([+-]?\d+(?:\.\d+)?)\s*[,，]\s*([+-]?\d+(?:\.\d+)?)/g;
      for (const m of text.matchAll(krRe)) {
        push(parseFloat(m[1]), parseFloat(m[2]), 'KR');
      }
      for (const m of text.matchAll(worldRe)) {
        push(parseFloat(m[1]), parseFloat(m[2]), 'WORLD');
      }
      if (out.length) return out;
      const lines = text.split(/\r?\n/);
      const firstLine = lines.find(l => l.trim().length);
      if (firstLine && /lat|longitude|위도|경도/i.test(firstLine)) {
        const hdr = firstLine.split(/,|\t|\s{2,}/);
        const idxLat = hdr.findIndex(h => /^(lat|latitude|위도)$/i.test(h.trim()));
        const idxLon = hdr.findIndex(h => /^(lon|lng|longitude|경도)$/i.test(h.trim()));
        if (idxLat >= 0 && idxLon >= 0) {
          for (let i = 1; i < lines.length; i++) {
            const line = lines[i];
            if (!line.trim()) continue;
            const cols = line.split(/,|\t|\s{2,}/);
            const lat = parseFloat(cols[idxLat]);
            const lon = parseFloat(cols[idxLon]);
            push(lat, lon);
          }
          if (out.length) return out;
        }
      }
      for (const m of text.matchAll(pairRe)) {
        push(parseFloat(m[1]), parseFloat(m[2]));
      }
      return out;
    }
    function buildResultRow(kind, r, extra) {
      const base = {
        '구분': kind,
        '순번': r.idx,
        '좌표 (위도,경도)': `${r.lat}, ${r.lon}`,
        '시·도': '',
        '시·군·구': '',
        '읍·면·동·리': '',
        '지물 태그': '',
        '전체주소': '',
        '지도링크': [],
      };
      return { ...base, ...extra };
    }
    function appendRow(row) {
      const tr = document.createElement('tr');
      const keys = [...BASE_COLUMNS, '지도링크'];
      for (const k of keys) {
        const isRowHeader = (k === '순번');
        const cellTag = (k === '지도링크') ? 'td' : (isRowHeader ? 'th' : 'td');
        const td = document.createElement(cellTag);
        if (isRowHeader && cellTag === 'th') td.setAttribute('scope', 'row');
        if (k === '지도링크') {
          td.classList.add('nowrap');
          const links = row[k];
          if (Array.isArray(links)) {
            for (let i = 0; i < links.length; i++) {
              const it = links[i];
              const a = document.createElement('a');
              a.href = it.url;
              a.target = '_blank';
              a.rel = 'noopener noreferrer';
              a.textContent = it.label;
              const latlon = String(row['좌표 (위도,경도)']);
              a.setAttribute('aria-label', `${it.label} 지도 새 창에서 열기 (${latlon})`);
              td.appendChild(a);
              if (i < links.length - 1) {
                td.appendChild(document.createTextNode(' · '));
              }
            }
          }
        } else {
          td.textContent = row[k] ?? '';
          if (k === '지물 태그') td.className = 'tags-cell';
          if (k === '읍·면·동·리') {
            td.classList.add('nowrap', 'ellipsis');
            td.title = row[k] ?? '';
          }
        }
        tr.appendChild(td);
      }
      els.tbody.appendChild(tr);
    }
    function toCSV(rows) {
      if (!rows || !rows.length) return '';
      const headers = [
        ...BASE_COLUMNS,
        ...MAP_PROVIDERS.map(p => p.header),
      ];
      const escape = (s) => {
        if (s == null) return '';
        s = String(s);
        if (/[",\n]/.test(s)) {
          return '"' + s.replaceAll('"', '""') + '"';
        }
        return s;
      };
      const lines = [headers.join(',')];
      for (const r of rows) {
        const links = (r['지도링크'] && Array.isArray(r['지도링크'])) ? r['지도링크'] : [];
        const linkMap = Object.fromEntries(links.map(l => [l.label, l.url]));
        const baseVals = BASE_COLUMNS.map(col => r[col]);
        const linkVals = MAP_PROVIDERS.map(p => linkMap[p.key] || '');
        const rowVals = [...baseVals, ...linkVals];
        lines.push(rowVals.map(escape).join(','));
      }
      return lines.join('\n');
    }
    function exportCSV() {
      try {
        if (!results || results.length === 0) {
          setStatus('내보낼 데이터가 없습니다. 먼저 조회 시작을 눌러주세요.', 'warn');
          return;
        }
        const csv = toCSV(results);
        if (!csv) {
          setStatus('CSV 데이터 생성에 실패했습니다.', 'error');
          return;
        }
        const bom = '\uFEFF';
        const blob = new Blob([bom + csv], { type: 'text/csv;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'reverse_geocode_results.csv';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        setStatus('CSV 파일을 다운로드했습니다.');
      } catch (err) {
        console.error('CSV Export Error:', err);
        setStatus(`내보내기 중 오류가 발생했습니다: ${err.message}`, 'error');
      }
    }
    function pushResultRow(row) {
      results.push(row);
      if (row['구분'] !== '에러') successCount++;
      processedCount++;
      appendRow(row);
      currentIndex++;
      setProgress(currentIndex, records.length);
    }
    async function runProcessingLoop() {
      for (let i = currentIndex; i < records.length; i++) {
        if (!running || stopFlag) break;
        if (paused && resumeHandler) {
          setStatus('일시정지됨. "재개"를 누르면 이어서 진행합니다. (단축키 S로 재개)', 'warn');
          await resumeHandler.promise;
        }
        if (!running || stopFlag) break;
        currentIndex = i;
        const r = records[i];
        const { lat, lon } = r;
        controller = new AbortController();
        inFlight = true;
        try {
          await sleep(CONFIG.RATE_LIMIT_DELAY_MS);
          if (!running || stopFlag) break;
          if (!paused) {
            setStatus(`처리 중… (${i + 1}/${records.length}) (단축키: S=일시정지, Esc=중지)`);
          }
          const data = await fetchReverseWithRetry(lat, lon, controller.signal);
          const addr = data.address ?? {};
          const { sido, sigungu, eupmyeon, tag } = toKoreanAddressParts(addr, data);
          const linkset = mapLinks(lat, lon);
          const row = buildResultRow(r.set, r, {
            '시·도': sido,
            '시·군·구': sigungu,
            '읍·면·동·리': eupmyeon,
            '지물 태그': tag,
            '전체주소': data.display_name || '',
            '지도링크': linkset,
          });
          pushResultRow(row);
        } catch (err) {
          const msg = err && (err.message || String(err));
          const isAbort = err && (err.name === 'AbortError' || /aborted/i.test(msg));
          if (stopFlag && isAbort) break;
          console.error(err);
          const row = buildResultRow('에러', r, { '전체주소': msg });
          pushResultRow(row);
          if (!stopFlag) {
            setStatus(`에러 발생: (${i + 1}/${records.length}) ${msg}`, 'error');
          }
        } finally {
          inFlight = false;
          updateCounts();
        }
      }
      if (stopFlag) {
        setControlsIdle('중지되었습니다.', 'warn');
      } else if (currentIndex >= records.length - 1) {
        setControlsIdle('모든 처리가 완료되었습니다.');
      }
    }
    function startProcessing() {
      stopFlag = false;
      running = true;
      resetProcessingState(records.length);
      setStatus('조회 시작… (단축키: S=일시정지, Esc=중지)');
      els.start.disabled = true;
      els.pause.disabled = false;
      els.resume.disabled = true;
      els.stop.disabled = false;
      setTableState('running');
      runProcessingLoop();
    }
    els.parse.addEventListener('click', async () => {
      try {
        if (running) {
          setStatus('현재 역지오코딩이 진행 중입니다. 중지 후 다시 좌표를 추출해 주세요.', 'warn');
          return;
        }
        els.start.disabled = true;
        els.exportBtn.disabled = true;
        const file = els.file.files?.[0];
        if (!file) {
          setStatus('먼저 random_data.txt 파일을 선택해 주세요.', 'warn');
          return;
        }
        setStatus('파일 읽는 중…');
        const text = await file.text();
        setStatus('좌표 추출 중…');
        await yieldToMain();
        const parsed = extractCoordinates(text);
        if (!parsed.length) {
          records = [];
          resetProcessingState(0);
          els.coords.value = '';
          els.start.disabled = true;
          setStatus(
            '좌표를 찾지 못했습니다. 라벨(대한민국/세계 위경도) 또는 "위도,경도" 형태를 확인해 주세요.',
            'warn'
          );
          return;
        }
        records = parsed.map((p, i) => ({
          set: p.setLabel ? (p.setLabel === 'KR' ? 'KR' : 'WORLD') : (isKR(p.lat, p.lon) ? 'KR' : 'WORLD'),
          idx: i + 1,
          lat: p.lat,
          lon: p.lon
        }));
        els.coords.value = records
          .map(r => `${r.lat},${r.lon}`)
          .join('\n');
        resetProcessingState(records.length);
        setControlsIdle(
          `분석 완료: ${records.length}개 좌표 발견. "조회 시작(단축키 S)"을 누르세요.`
        );
      } catch (err) {
        console.error(err);
        setStatus(`오류 발생: ${err.message}`, 'error');
        els.start.disabled = true;
      }
    });
    els.start.addEventListener('click', () => {
      if (!document.startViewTransition) {
        startProcessing();
      } else {
        document.startViewTransition(() => {
          startProcessing();
        });
      }
    });
    els.pause.addEventListener('click', () => {
      if (!running) return;
      paused = true;
      if (!resumeHandler) {
        resumeHandler = Promise.withResolvers();
      }
      if (inFlight) {
        setStatus('일시정지 요청됨. 현재 작업을 마치고 멈춥니다...', 'warn');
      } else {
        setStatus('일시정지됨. "재개"를 누르면 이어서 진행합니다. (단축키 S로 재개)', 'warn');
      }
      els.pause.disabled = true;
      els.resume.disabled = false;
    });
    els.resume.addEventListener('click', () => {
      if (!running || !paused) return;
      paused = false;
      setStatus('재개합니다… (단축키 Esc로 중지)');
      if (resumeHandler) {
        resumeHandler.resolve();
        resumeHandler = null;
      }
      els.pause.disabled = false;
      els.resume.disabled = true;
    });
    els.stop.addEventListener('click', () => {
      if (!running) return;
      stopFlag = true;
      if (paused && resumeHandler) {
        resumeHandler.resolve();
        resumeHandler = null;
        paused = false;
      }
      if (inFlight && controller) {
        controller.abort();
        setStatus('중지 요청됨. 현재 요청을 취소하는 중입니다…', 'warn');
      } else {
        setControlsIdle('중지되었습니다.', 'warn');
      }
    });
    els.exportBtn.addEventListener('click', exportCSV);
    els.file.addEventListener('change', () => {
      if (els.file.files.length > 0) {
        const f = els.file.files[0];
        if (f.type && !f.type.startsWith('text/')) {
          setStatus('텍스트 파일(.txt)만 지원합니다.', 'warn');
          els.file.value = '';
          return;
        }
        setStatus(`파일이 선택되었습니다: ${f.name} (단축키 P를 눌러 추출하세요)`);
      }
    });
    const dropZone = document.body;
    dropZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropZone.style.opacity = '0.8';
    });
    dropZone.addEventListener('dragleave', (e) => {
      e.preventDefault();
      dropZone.style.opacity = '1';
    });
    dropZone.addEventListener('drop', (e) => {
      e.preventDefault();
      dropZone.style.opacity = '1';
      const files = e.dataTransfer.files;
      if (files.length > 0) {
        const f = files[0];
        if (f.type && !f.type.startsWith('text/')) {
          setStatus('텍스트 파일(.txt)만 지원합니다.', 'warn');
          els.file.value = '';
          return;
        }
        els.file.files = files;
        setStatus(`파일이 선택되었습니다: ${f.name} (단축키 P를 눌러 추출하세요)`);
      }
    });
    window.addEventListener('keydown', (e) => {
      const active = document.activeElement;
      if (active.tagName === 'TEXTAREA' || (active.tagName === 'INPUT' && active.type === 'text')) {
        return;
      }
      const key = e.key.toLowerCase();
      if (key === 'p' && !els.parse.disabled) {
        e.preventDefault();
        els.parse.click();
      }
      if (e.key === 'Escape' && !els.stop.disabled) {
        e.preventDefault();
        els.stop.click();
      }
      if (key === 's') {
        if (!els.resume.disabled) {
          e.preventDefault();
          els.resume.click();
        } else if (!els.pause.disabled) {
          e.preventDefault();
          els.pause.click();
        } else if (!els.start.disabled) {
          e.preventDefault();
          els.start.click();
        }
      }
    });
  </script>
</body>

</html>