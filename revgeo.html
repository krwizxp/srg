<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>SRG 데이터 역지오코딩 도구</title>
  <meta name="description" content="SRG가 생성하는 random_data.txt 파일의 위경도 좌표를 주소로 변환(역지오코딩)해주는 웹 도구입니다.">
  <meta property="og:type" content="website">
  <meta property="og:title" content="SRG 데이터 역지오코딩 도구">
  <meta property="og:description" content="좌표 데이터를 주소로 변환합니다.">
  <meta property="og:locale" content="ko_KR">
  <link rel="icon" href="icon.svg">
  <link rel="manifest" href="site.webmanifest">
  <link rel="preconnect" href="https://nominatim.openstreetmap.org" crossorigin>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="stylesheet" crossorigin
    href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard.min.css?ver=1.3.9">
  <style>
    @property --mouse-x {
      syntax: "<length>";
      inherits: true;
      initial-value: 0px;
    }

    @property --mouse-y {
      syntax: "<length>";
      inherits: true;
      initial-value: 0px;
    }

    @property --pct {
      syntax: "<number>";
      inherits: true;
      initial-value: 0;
    }

    @layer reset {

      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }

      :is(body, fieldset, h1, h2, p, pre) {
        margin-block: 0;
        margin-inline: 0;
      }

      fieldset {
        padding-block: 0;
        padding-inline: 0;
        border: 0;
      }

      :is(input, button, select) {
        font: inherit;
      }

      :is(input, select) {
        @media (pointer: coarse) {
          font-size: 16px !important;
          letter-spacing: -0.03em;
        }
      }

      body {
        word-break: keep-all;
        min-block-size: 100dvh;
        text-wrap: pretty;
        container-type: inline-size;
        container-name: page;
        overscroll-behavior: none;
      }
    }

    @layer theme {
      :root {
        color-scheme: light dark;
        --safe-inline-start: env(safe-area-inset-left);
        --safe-inline-end: env(safe-area-inset-right);
        --inline-origin-x: 0%;
        --inline-angle: 90deg;
        --shimmer-from: -120%;
        --shimmer-to: 120%;
        --page-bg: light-dark(oklch(100% 0 0), oklch(12% 0.02 265));
        --card-surface: color-mix(in oklch,
            light-dark(oklch(94.5% 0.014 265 / 0.96), oklch(17% 0.03 265 / 0.82)) 90%,
            var(--surface-panel));
        --fg: light-dark(oklch(18% 0.114 275),
            oklch(95% 0.04 275));
        --tone-base: light-dark(oklch(98% 0.008 270), oklch(16% 0.03 270));
        --muted: light-dark(color-mix(in oklch, var(--fg) 72%, var(--tone-base)),
            color-mix(in oklch, var(--fg) 82%, var(--tone-base)));
        --muted-strong: light-dark(color-mix(in oklch, var(--fg) 82%, var(--tone-base)),
            color-mix(in oklch, var(--fg) 90%, var(--tone-base)));
        --line-soft: light-dark(color-mix(in oklch, var(--fg) 58%, var(--surface-panel)),
            color-mix(in oklch, var(--fg) 48%, var(--surface-panel)));
        --accent: light-dark(oklch(50% 0.18 275),
            oklch(64% 0.16 270));
        --accent-ink: color-mix(in oklch, var(--accent) 70%, var(--fg));
        --accent-border: color-mix(in oklch, var(--accent) 40%, var(--line-soft));
        --accent-wash: color-mix(in oklch, var(--accent) 5%, var(--surface-panel));
        --warn: light-dark(oklch(70% 0.22 65), oklch(82% 0.20 70));
        --err: light-dark(oklch(58% 0.26 28), oklch(72% 0.24 28));
        --spotlight: light-dark(color-mix(in oklch, var(--accent) 7%, transparent),
            color-mix(in oklch, var(--accent) 14%, transparent));
        --surface-panel: light-dark(color-mix(in oklch,
              oklch(100% 0.008 270 / 0.5) 88%,
              oklch(94.5% 0.014 265 / 0.96)),
            color-mix(in oklch,
              oklch(18% 0.08 270 / 0.45) 78%,
              oklch(17% 0.03 265 / 0.82)));
        --panel-bg: color-mix(in oklch, var(--surface-panel) 88%, var(--card-surface));
        --panel-shadow: light-dark(0 6px 16px -14px color-mix(in oklch, var(--fg) 18%, transparent),
            0 10px 18px -16px color-mix(in oklch, var(--fg) 40%, transparent));
        --fs-sm: clamp(13px, 0.9vw, 14px);
        --results-pane-mobile-height: 70dvh;
        font-family: "Pretendard", -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
        scrollbar-width: thin;
        scrollbar-color: color-mix(in oklch,
            color-mix(in oklch, var(--line-soft) 75%, var(--surface-panel)) 82%, var(--accent) 18%) transparent;
      }

      :root[dir="rtl"] {
        --safe-inline-start: env(safe-area-inset-right);
        --safe-inline-end: env(safe-area-inset-left);
        --inline-origin-x: 100%;
        --inline-angle: 270deg;
        --shimmer-from: 120%;
        --shimmer-to: -120%;
      }

      :root[data-theme="light"] {
        color-scheme: light;
      }

      :root[data-theme="dark"] {
        color-scheme: dark;
      }

      html {
        background-color: var(--page-bg);
      }

      body {
        color: var(--fg);
        padding-block: max(20px, env(safe-area-inset-top)) max(20px, env(safe-area-inset-bottom));
        padding-inline: max(20px, var(--safe-inline-start)) max(20px, var(--safe-inline-end));
        letter-spacing: -.015em;
        font-variant-numeric: tabular-nums;
        font-size: clamp(14px, 1.5vw, 15px);
        line-height: 1.6;

        &::selection {
          background: color-mix(in oklch, var(--accent) 25%, var(--card-surface));
          color: var(--fg);
        }

        @container (inline-size <=800px) {
          padding-block: max(12px, env(safe-area-inset-top)) max(12px, env(safe-area-inset-bottom));
          padding-inline: max(12px, var(--safe-inline-start)) max(12px, var(--safe-inline-end));
        }
      }
    }

    @layer layout {
      main {
        inline-size: min(1600px, 100%);
        margin-inline: auto;
        display: grid;
        grid-template-columns: clamp(380px, 28vw, 440px) 1fr;
        gap: 20px;
        block-size: clamp(700px, calc(100dvh - 40px), 1100px);

        @container (inline-size <=900px) {
          grid-template-columns: 1fr;
          block-size: auto;
        }
      }
    }

    @layer components {

      .coords-view,
      .table-wrap {
        flex: 1;
        scrollbar-width: thin;
        overflow: auto;
        --scroll-shadow-size: 14px;
        --scroll-shadow-color: color-mix(in oklch, var(--line-soft) 70%, transparent);
      }

      .coords-view {
        --coords-pad-block: 12px;
        --coords-pad-inline: 12px;
      }

      .coords-view[data-has-content]::before,
      .coords-view[data-has-content]::after,
      .table-wrap.has-results::before,
      .table-wrap.has-results::after {
        content: "";
        display: block;
        position: sticky;
        inset-inline: 0;
        block-size: var(--scroll-shadow-size);
        pointer-events: none;
        z-index: 5;
        opacity: 0;
      }

      .coords-view[data-has-content]::before,
      .table-wrap.has-results::before {
        inset-block-start: var(--table-head-offset, 0px);
        margin-block-start: calc(-1 * var(--scroll-shadow-size));
        background: linear-gradient(180deg, var(--scroll-shadow-color), transparent);
      }

      .coords-view[data-has-content]::after,
      .table-wrap.has-results::after {
        inset-block-end: 0;
        margin-block-end: calc(-1 * var(--scroll-shadow-size));
        background: linear-gradient(0deg, var(--scroll-shadow-color), transparent);
      }

      :is(.coords-view[data-has-content], .table-wrap.has-results)[data-at-top][data-at-bottom]::before,
      :is(.coords-view[data-has-content], .table-wrap.has-results)[data-at-top][data-at-bottom]::after,
      :is(.coords-view[data-has-content], .table-wrap.has-results)[data-shadow-rebind]::before,
      :is(.coords-view[data-has-content], .table-wrap.has-results)[data-shadow-rebind]::after {
        animation: none !important;
      }

      @keyframes scroll-shadow-top {
        from {
          opacity: 0;
        }

        to {
          opacity: 1;
        }
      }

      @keyframes scroll-shadow-bottom {
        from {
          opacity: 1;
        }

        to {
          opacity: 0;
        }
      }

      @supports (animation-timeline: scroll()) {

        :is(.coords-view[data-has-content], .table-wrap.has-results)::before,
        :is(.coords-view[data-has-content], .table-wrap.has-results)::after {
          animation-timeline: scroll();
          animation-range: 0% 100%;
          animation-duration: 1s;
          animation-timing-function: linear;
          animation-fill-mode: both;
        }

        :is(.coords-view[data-has-content], .table-wrap.has-results)::before {
          animation-name: scroll-shadow-top;
        }

        :is(.coords-view[data-has-content], .table-wrap.has-results)::after {
          animation-name: scroll-shadow-bottom;
        }
      }

      @keyframes skeleton-shimmer-x {
        from {
          transform: translateX(var(--shimmer-from));
        }

        to {
          transform: translateX(var(--shimmer-to));
        }
      }

      @keyframes row-fade-in {
        from {
          opacity: 0;
        }
      }

      :is(.card, .card-stack, .map-popover) {
        background: var(--card-surface);
        box-shadow: 0 12px 20px -16px color-mix(in oklch, var(--fg) 18%, transparent);
      }

      :is(.card, .card-stack) {
        border-radius: clamp(20px, 2vw, 28px);
        overflow: hidden;
      }

      :is(.card, .card-stack-spotlight) {
        --spotlight-radius: 800px;
      }

      :is(.card, .card-stack-spotlight)::before {
        content: "";
        position: absolute;
        pointer-events: none;
        inset-block-start: 0;
        inset-inline-start: 0;
        inline-size: calc(var(--spotlight-radius) * 2);
        block-size: calc(var(--spotlight-radius) * 2);
        background: radial-gradient(in oklch circle,
            var(--spotlight),
            transparent 30%);
        transform: translate3d(calc(var(--mouse-x) - var(--spotlight-radius)),
            calc(var(--mouse-y) - var(--spotlight-radius)),
            0);
        opacity: 0;
        transition:
          opacity .5s ease-out,
          --mouse-x 90ms linear,
          --mouse-y 90ms linear;
      }

      .card {
        padding-block: clamp(20px, 2.5vw, 32px);
        padding-inline: clamp(20px, 2.5vw, 32px);
        display: flex;
        flex-direction: column;
        gap: 10px;
        position: relative;
        container-type: inline-size;
        min-block-size: 0;

        .card-header {
          display: flex;
          align-items: baseline;
          gap: 12px;
          flex-wrap: wrap;

          h2 {
            font-size: clamp(18px, 1.6vw, 22px);
          }

          .header-desc {
            color: var(--muted-strong);
          }
        }

        >div:has(#coords) {
          flex: 1;
          display: flex;
          flex-direction: column;
          min-block-size: 0;
          gap: 6px;
        }

        footer {
          text-align: center;
          font-size: var(--fs-sm);
          color: var(--muted);
          line-height: 1.3;
        }

        &::before {
          z-index: 1;
        }

        &:active:not(.no-spotlight)::before {
          opacity: 0.6;
          transition: none;
        }

        &.no-spotlight::before {
          opacity: 0;
        }

        .brand {
          display: flex;
          align-items: flex-start;
          gap: 14px;
          color: var(--accent-ink);

          .theme-toggle {
            margin-inline-start: auto;
            align-self: flex-start;
          }

          @container page (inline-size <=600px) {
            flex-wrap: wrap;

            .theme-toggle {
              margin-block-start: 6px;
            }
          }

          svg {
            fill: currentColor;
            inline-size: 36px;
            block-size: 36px;
            flex: 0 0 auto;
            margin-block-start: 2px;
          }

          >div {
            display: flex;
            flex-direction: column;
            gap: 2px;

            h1 {
              font-size: clamp(22px, 2vw, 28px);
              font-weight: 800;
              line-height: 1.1;
            }

            p {
              color: var(--muted-strong);
              font-size: var(--fs-sm);
              font-weight: 500;
              line-height: 1.25;
            }
          }
        }

        fieldset.row {
          display: flex;
          flex-direction: column;
          gap: 16px;

          .row {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
          }
        }

        .drop-zone {
          position: relative;
          border: 1px dashed var(--line-soft);
          border-radius: 18px;
          padding-block: 12px;
          padding-inline: 16px;
          transition: .2s ease;
          background: var(--panel-bg);
          display: flex;
          flex-direction: column;
          align-items: center;
          gap: 10px;
          color: var(--muted);
          font-weight: 500;
          font-size: var(--fs-sm);

          input[type="file"] {
            position: absolute;
            inset-block: 0;
            inset-inline: 0;
            opacity: 0;
            cursor: pointer;
          }

          .drop-icon {
            inline-size: 36px;
            block-size: 36px;
            transition: .2s ease;
            stroke-width: 1.5;
          }

          .drop-text strong {
            color: var(--accent-ink);
          }

          &:is(:hover, :focus-within) {
            border-color: var(--accent-border);
            background: var(--accent-wash);

            .drop-icon {
              color: var(--accent-ink);
            }
          }

          .mobile-msg {
            display: none;
          }

          @media (pointer: coarse) {
            @container page (inline-size <=800px) {
              padding-block: 16px;

              .desktop-msg {
                display: none;
              }

              .mobile-msg {
                display: inline;
              }
            }
          }

          &[inert] {
            opacity: 0.5;
          }
        }

        :where(.drop-icon, .theme-toggle svg) {
          fill: none;
          stroke: currentColor;
          stroke-linecap: round;
          stroke-linejoin: round;
        }

        :where(.coords-view,
          button,
          .filters input[type="search"],
          .filters select) {
          border-radius: 12px;
          background-color: var(--panel-bg);
          transition: .2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        :where(button,
          .filters input[type="search"],
          .filters select) {
          border: 0;
          color: var(--fg);
        }

        :where(.coords-view,
          .drop-zone,
          .table-wrap,
          .filters input[type="search"],
          .filters select) {
          box-shadow: var(--panel-shadow);
        }

        :where(.coords-view, .coords-view .coords-content) {
          font: inherit;
        }

        .coords-view {
          min-block-size: 100px;
          line-height: 1.5;
          font-size: clamp(12px, 3.5cqi, 14px);
        }

        :where(.coords-view) :is(.coords-placeholder, .coords-content) {
          display: block;
          padding-block: var(--coords-pad-block);
          padding-inline: var(--coords-pad-inline);
        }

        .coords-view .coords-placeholder {
          color: var(--muted-strong);
        }

        .coords-view[data-has-content] .coords-placeholder {
          display: none;
        }

        .coords-view:not([data-has-content]) .coords-content {
          display: none;
        }

        @container page (inline-size <=900px) {
          .coords-view {
            max-block-size: 30dvh;
          }
        }

        :where(button,
          .filters input[type="search"],
          .filters select,
          .map-popover,
          .map-popover a):focus-visible {
          outline: none;
          box-shadow: inset 0 0 0 2px var(--accent-border);
        }

        button {
          cursor: pointer;
          font-weight: 600;
          display: inline-flex;
          align-items: center;
          justify-content: center;
          min-inline-size: 0;
          white-space: nowrap;
          padding-block: 12px;
          padding-inline: 8px;
          position: relative;

          &::after {
            content: "";
            position: absolute;
            inset-block: 0;
            inset-inline: 0;
            background: radial-gradient(in oklch circle at var(--mouse-x) var(--mouse-y),
                color-mix(in oklch, var(--accent) 6%, transparent),
                transparent 70%);
            opacity: 0;
            transition:
              opacity .5s ease-out,
              --mouse-x 90ms linear,
              --mouse-y 90ms linear;
          }

          @media (any-hover: hover) {
            &:hover {
              background: var(--accent-wash);
            }
          }

          &:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            filter: grayscale(0.8);
          }

          &:is(#parse, #start) {
            background: light-dark(color-mix(in oklch, var(--accent) 85%, var(--fg)),
                color-mix(in oklch, var(--accent) 42%, var(--surface-panel)));
            color: light-dark(color-mix(in oklch, var(--tone-base) 99%, var(--fg)),
                color-mix(in oklch, var(--fg) 98%, var(--tone-base)));

            &:not(:disabled) {
              &:hover {
                background: light-dark(color-mix(in oklch, var(--accent) 82%, var(--fg)),
                    color-mix(in oklch, var(--accent) 38%, var(--surface-panel)));
              }
            }
          }

          &:is(#parse, #start):focus-visible {
            box-shadow:
              inset 0 0 0 2px var(--accent-border),
              0 0 0 3px var(--accent-border);
          }

          &#stop {
            color: light-dark(color-mix(in oklch, var(--err) 60%, var(--fg)),
                color-mix(in oklch, var(--err) 80%, var(--fg)));

            &:not(:disabled) {
              &:hover {
                background: color-mix(in oklch, var(--err) 4%, var(--surface-panel));
              }
            }
          }

          &:is(#parse, #start, #pause, #resume, #stop, #export, #filter-clear)::after {
            will-change: opacity;
          }

          &:not(:disabled):active::after {
            opacity: 0.4;
            transition: none;
          }

          &.theme-toggle {
            border-radius: 999px;
            font-size: var(--fs-sm);
            color: var(--muted-strong);
            inline-size: 44px;
            block-size: 44px;
            padding-block: 0;
            padding-inline: 0;

            &::after {
              display: none;
            }

            svg {
              display: block;
              inline-size: 18px;
              block-size: 18px;
              stroke-width: 1.6;
            }

            .icon-sun {
              display: none;
            }
          }
        }
      }

      :root[data-theme="dark"] .theme-toggle {
        .icon-sun {
          display: block;
        }

        .icon-moon {
          display: none;
        }
      }

      :is(.progress-shell, .skeleton-bar) {
        border-radius: 999px;
      }

      .row-progress {
        display: flex;
        align-items: flex-end;
        gap: 12px;
        margin-block-start: 8px;
        line-height: 1.15;

        >.sp {
          flex: 1;
          display: flex;
          flex-direction: column;
          gap: 8px;
          min-inline-size: 0;
        }

        #counts {
          flex: 0 0 auto;
          font-size: var(--fs-sm);
          text-align: end;
          white-space: nowrap;
          color: var(--muted);

          strong {
            color: var(--fg);
          }
        }
      }

      .progress-shell {
        position: relative;
        overflow: hidden;
        contain: paint;
        background: color-mix(in oklch, var(--fg) 12%, var(--surface-panel));
        block-size: 8px;
        transition: --pct 0.3s cubic-bezier(0.25, 1, 0.5, 1);

        >progress {
          opacity: 0;
        }

        .progress-visual {
          position: absolute;
          inset-block: 0;
          inset-inline: 0;
        }

        .progress-fill {
          block-size: 100%;
          overflow: hidden;
          transform: scaleX(calc(var(--pct) / 100));
          transform-origin: var(--inline-origin-x) 50%;
          background: linear-gradient(in oklch var(--inline-angle),
              color-mix(in oklch, var(--accent) 85%, var(--fg)),
              color-mix(in oklch, var(--accent) 78%, var(--fg)));
          position: relative;
        }

        &.active {
          .progress-fill::after {
            content: "";
            position: absolute;
            inset-block: 0;
            inset-inline: 0;
            transform: translateX(var(--shimmer-from));
            background: linear-gradient(in oklch var(--inline-angle),
                transparent 0%,
                color-mix(in oklch, var(--page-bg) 75%, transparent) 45%,
                transparent 100%);
            opacity: light-dark(.78, .55);
            animation: skeleton-shimmer-x 1.5s linear infinite;
            will-change: transform;
            pointer-events: none;
          }
        }
      }

      .card-stack {
        position: relative;
        display: flex;
        flex-direction: column;
        block-size: 100%;
        min-block-size: 0;

        @container page (inline-size <=900px) {
          block-size: auto;
        }

        .card-stack-spotlight {
          position: absolute;
          inset-block: 0;
          inset-inline: 0;
          pointer-events: none;
          z-index: 2;

          &.suppressed::before {
            opacity: 0;
          }
        }

        &:active {
          .card-stack-spotlight::before {
            opacity: 0.6;
            transition: none;
          }

          .card-stack-spotlight.suppressed::before {
            opacity: 0;
          }
        }

        &:has(.table-wrap:active) {
          .card-stack-spotlight::before {
            opacity: 0;
          }
        }

        .card-stack-content {
          display: flex;
          flex-direction: column;
          flex: 1;
          min-block-size: 0;
          position: relative;
          z-index: 1;

          >.card {
            background: transparent;
            box-shadow: none;
            border-radius: 0;
          }
        }

        .card-stack-top {
          padding-block-end: 0;
        }

        .card-stack-bottom {
          padding-block-start: 10px;
          display: flex;
          flex-direction: column;
          flex: 1;
          min-block-size: 0;

          .table-wrap {
            min-block-size: 0;
          }
        }
      }

      .status {
        padding-block: 12px;
        padding-inline: 16px;
        border-radius: 12px;
        background: light-dark(color-mix(in oklch, var(--muted) 8%, var(--surface-panel)),
            color-mix(in oklch, var(--muted) 12%, var(--surface-panel)));
        border-inline-start: 2px solid color-mix(in oklch, var(--muted) 70%, var(--line-soft));
        flex-shrink: 0;
        font-weight: 500;
        font-size: var(--fs-sm);
        transition: opacity .3s, transform .3s, display .3s allow-discrete;

        &:empty {
          display: none;
          opacity: 0;
          transform: translateY(5px);
        }

        @starting-style {
          opacity: 0;
          transform: translateY(5px);
        }

        &.err {
          color: color-mix(in oklch, var(--err) 45%, var(--fg));
          border-inline-start-color: color-mix(in oklch, var(--err) 70%, var(--line-soft));
          background: color-mix(in oklch, var(--err) 10%, var(--surface-panel));
        }

        &.warn {
          color: color-mix(in oklch, var(--warn) 35%, var(--fg));
          border-inline-start-color: color-mix(in oklch, var(--warn) 50%, var(--fg));
          background: color-mix(in oklch, var(--warn) 10%, var(--surface-panel));
        }

        &.stopped {
          color: var(--muted-strong);
          background: light-dark(color-mix(in oklch, var(--muted) 12%, var(--surface-panel)),
              color-mix(in oklch, var(--muted) 16%, var(--surface-panel)));
        }
      }

      .table-wrap {
        border-radius: 20px;
        background-color: var(--panel-bg);
        scrollbar-gutter: stable;
        position: relative;

        .table-hint {
          display: grid;
          place-items: center;
          position: absolute;
          inset-block: 50px 0;
          inset-inline: 0;
          color: var(--muted);
          pointer-events: none;
        }

        .filter-empty-hint {
          display: none;
        }

        &.has-results .empty-hint {
          display: none;
        }

        &.filter-empty .filter-empty-hint {
          display: grid;
        }

        @container (inline-size <=900px) {
          block-size: var(--results-pane-mobile-height);
          flex: 0 0 var(--results-pane-mobile-height);
          overscroll-behavior: contain;

          .table-hint {
            inset-block-start: 0;
          }
        }
      }

      .filters {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-block: 10px 12px;

        :is(input[type="search"], select) {
          padding-block: 10px;
          padding-inline: 12px;
        }

        input[type="search"] {
          min-inline-size: 220px;
          flex: 1 1 220px;
        }

        input[type="search"]::placeholder {
          color: var(--muted-strong);
          opacity: 1;
        }

        select {
          flex: 0 0 auto;
        }

        #filter-clear {
          flex: 0 0 auto;
          padding-inline: 12px;
        }

        @container page (inline-size >=1550px) {
          flex-wrap: nowrap;
          align-items: center;
          overflow-inline: auto;
          max-inline-size: 100%;

          input[type="search"] {
            min-inline-size: 120px;
            flex: 0 1 140px;
          }
        }
      }

      :is(th, td) {
        padding-block: 14px;
        padding-inline: 12px;
        font-size: var(--fs-sm);
      }

      table {
        inline-size: 100%;
        border-spacing: 0;

        thead {
          th {
            position: sticky;
            inset-block-start: 0;
            z-index: 10;
            background: color-mix(in oklch, var(--surface-panel) 78%, var(--tone-base));
            text-align: start;
            font-weight: 600;
            color: var(--muted-strong);
            white-space: nowrap;

            &:nth-child(-n + 2) {
              text-align: center;
            }

            &:nth-child(8) {
              inline-size: 100%;
            }
          }
        }

        tbody {
          td {
            vertical-align: top;

            &:nth-child(-n + 2) {
              color: var(--muted);
            }

            &:nth-child(3) {
              color: var(--accent-ink);
              font-weight: 500;
              letter-spacing: -0.03em;
            }
          }

          tr {
            content-visibility: auto;
            contain-intrinsic-block-size: auto 73px;

            @media (any-hover: hover) {
              &:hover {
                background: color-mix(in oklch, var(--accent) 4%, var(--surface-panel));
              }
            }

            &[hidden="until-found"] {
              display: block;
              content-visibility: hidden;
              block-size: 0;
              overflow: hidden;
            }
          }
        }

        @container (inline-size >900px) {
          tbody {
            td:nth-child(-n + 2) {
              text-align: center;
            }
          }
        }

        @container (inline-size <=900px) {
          display: block;
          min-inline-size: 0;

          thead {
            display: none;
          }

          tbody {
            display: flex;
            flex-direction: column;
            padding-block: 16px;
            padding-inline: 16px;

            tr:not([hidden])+tr:not([hidden]) {
              margin-block-start: 16px;
            }

            tr {
              contain-intrinsic-block-size: auto 375px;
              display: flex;
              flex-direction: column;
              gap: 10px;
              padding-block: 16px;
              padding-inline: 16px;
              background: color-mix(in oklch, var(--surface-panel) 86%, var(--card-surface));
              border-radius: 16px;
              box-shadow: 0 1px 2px color-mix(in oklch, var(--fg) 12%, transparent),
                0 1px 1px color-mix(in oklch, var(--fg) 8%, transparent);
              animation: row-fade-in 1s both;
              animation-timeline: view();
              animation-range: entry 0% cover 25%;

              td {
                display: grid;
                grid-template-columns: 64px 1fr;
                gap: 10px;
                align-items: baseline;
                padding-block: 2px;
                padding-inline: 0;

                &::before {
                  content: attr(data-label);
                  font-weight: 600;
                  color: var(--muted);
                  text-transform: uppercase;
                  letter-spacing: 0.05em;
                }
              }
            }

            :root[data-perf-mode="1"] & tr {
              animation: none !important;

              &:hover {
                background: transparent !important;
              }
            }
          }
        }

        .skeleton-bar {
          block-size: 1.1em;
          margin-block: 4px;
          position: relative;
          overflow: hidden;
          contain: paint;
          background: light-dark(color-mix(in oklch, var(--fg) 62%, var(--surface-panel)),
              color-mix(in oklch, var(--fg) 55%, var(--surface-panel)));

          &::after {
            content: "";
            position: absolute;
            inset-block: 0;
            inset-inline: 0;
            transform: translateX(var(--shimmer-from));
            background: linear-gradient(in oklch var(--inline-angle),
                transparent,
                color-mix(in oklch, var(--accent) 18%, var(--surface-panel)),
                transparent);
            animation: skeleton-shimmer-x 1.5s linear infinite;
            will-change: transform;
          }
        }
      }
    }

    @layer transitions {
      .card {
        &:has(#tbl) {
          .table-wrap {
            view-transition-name: results-card;
          }
        }
      }

      html:active-view-transition-type(results) {

        &::view-transition-old(root),
        &::view-transition-new(root) {
          animation: none;
        }

        &::view-transition-group(results-card) {
          animation-duration: 0.5s;
          animation-timing-function: cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        &::view-transition-old(results-card),
        &::view-transition-new(results-card) {
          position: absolute;
          inset-block: 0;
          inset-inline: 0;
          mix-blend-mode: plus-lighter;
          backface-visibility: hidden;
        }

        &::view-transition-old(results-card) {
          animation: 300ms cubic-bezier(0.4, 0, 0.2, 1) both vt-fade-out-blur;
          transform-origin: 50% 100%;
        }

        &::view-transition-new(results-card) {
          animation: 500ms cubic-bezier(0.25, 1, 0.5, 1) both vt-slide-in-spring;
          transform-origin: 50% 0%;
        }
      }

      @keyframes vt-fade-out-blur {
        0% {
          opacity: 1;
          filter: blur(0);
          transform: scale(1);
        }

        100% {
          opacity: 0;
          filter: blur(12px);
          transform: scale(0.92) translateY(10px);
        }
      }

      @keyframes vt-slide-in-spring {
        0% {
          opacity: 0;
          filter: blur(12px);
          transform: scale(0.96) translateY(20px);
        }

        50% {
          opacity: 1;
        }

        100% {
          opacity: 1;
          filter: blur(0);
          transform: scale(1) translateY(0);
        }
      }
    }

    @media (prefers-reduced-motion: reduce) {

      *,
      *::before,
      *::after {
        animation: none !important;
        transition: none !important;
      }
    }

    html.scrolling {
      @media (any-hover: hover) {
        .table-wrap table tbody tr:hover {
          background: transparent !important;
        }
      }
    }

    :root[data-perf-mode="1"] {

      .card::before,
      .card-stack-spotlight::before,
      button::after {
        opacity: 0 !important;
        transition: none !important;
      }
    }

    @layer utilities {
      .caps {
        text-transform: uppercase;
        letter-spacing: 0.06em;
        font-size: var(--fs-sm);
        font-weight: 700;
        color: var(--muted);
      }

      .sr-only {
        position: absolute;
        inline-size: 1px;
        block-size: 1px;
        clip-path: inset(50%);
      }

      .map-btn {
        padding-block: 8px;
        padding-inline: 10px;
        border-radius: 10px;
        color: var(--accent-ink);
        font-weight: 700;
      }

      td[data-label="지도링크"] {
        .map-btn:disabled {
          display: none;
        }
      }

      .map-popover {
        padding-block: 10px;
        padding-inline: 12px;
        border-radius: 14px;
        border: 0;
        max-inline-size: min(360px, 92vw);
        transition: opacity 0s linear 16ms;

        &:focus-visible {
          box-shadow:
            0 12px 20px -16px color-mix(in oklch, var(--fg) 18%, transparent),
            0 0 0 2px var(--accent-border);
        }

        @starting-style {
          opacity: 0;
        }

        .map-links {
          display: flex;
          flex-wrap: wrap;
          gap: 6px 8px;
          min-inline-size: 85px;
          color: var(--accent-ink);
          font-weight: 700;
          white-space: nowrap;

          a {
            color: inherit;
            text-decoration: none;
            transition: color 0.2s;

            &:is(:focus, :focus-visible) {
              outline: none;
              box-shadow: 0 0 0 2px var(--accent-border);
              border-radius: 8px;
            }

            @media (any-hover: hover) {
              &:hover {
                color: color-mix(in oklch, var(--accent) 55%, var(--fg));
                text-decoration: underline;
                text-underline-offset: 3px;
              }
            }
          }
        }

        position-area: block-end span-inline-start;
        position-try-fallbacks: flip-inline,
        flip-block,
        flip-block flip-inline;
      }
    }
  </style>
</head>

<body>
  <main id="app">
    <section class="card">
      <header class="brand">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" aria-hidden="true">
          <path
            d="M256,0C153.755,0,70.573,83.182,70.573,185.426c0,126.888,165.939,313.167,173.004,321.035 c6.636,7.391,18.222,7.378,24.849,0c7.065-7.868,173.004-194.147,173.004-321.035C441.427,83.182,358.245,0,256,0z M256,278.719c-51.442,0-93.292-41.851-93.292-93.292c0-51.441,41.851-93.292,93.292-93.292 c51.441,0,93.292,41.851,93.292,93.292C349.292,236.868,307.441,278.719,256,278.719z" />
        </svg>
        <div>
          <h1>SRG 역지오코딩</h1>
          <p>random_data.txt 좌표 변환</p>
        </div>
        <button type="button" class="theme-toggle" id="theme-toggle" aria-pressed="false" aria-label="테마 전환">
          <svg class="icon-sun" viewBox="0 0 24 24" aria-hidden="true">
            <circle cx="12" cy="12" r="4"></circle>
            <path
              d="M12 2v2M12 20v2M4.93 4.93l1.41 1.41M17.66 17.66l1.41 1.41M2 12h2M20 12h2M4.93 19.07l1.41-1.41M17.66 6.34l1.41-1.41">
            </path>
          </svg>
          <svg class="icon-moon" viewBox="0 0 24 24" aria-hidden="true">
            <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
          </svg>
          <span class="sr-only" id="theme-toggle-label">다크 모드</span>
        </button>
      </header>
      <h2 class="sr-only">파일 업로드 및 실행</h2>
      <form>
        <fieldset class="row">
          <legend class="sr-only">
            random_data.txt 파일 업로드 및 조회 제어
          </legend>
          <label class="drop-zone">
            <svg class="drop-icon" viewBox="0 0 24 24" aria-hidden="true">
              <path
                d="M2.25 12.75V12A2.25 2.25 0 014.5 9.75h15A2.25 2.25 0 0121.75 12v.75m-8.69-6.44l-2.12-2.12a1.5 1.5 0 00-1.061-.44H4.5A2.25 2.25 0 002.25 6v12a2.25 2.25 0 002.25 2.25h15A2.25 2.25 0 0021.75 18V9a2.25 2.25 0 00-2.25-2.25h-5.379a1.5 1.5 0 01-1.06-.44z" />
            </svg>
            <span class="drop-text">
              <span class="desktop-msg">클릭(드래그 앤 드롭)하여 <strong>random_data.txt</strong> 업로드</span>
              <span class="mobile-msg">터치하여 <strong>random_data.txt</strong> 업로드</span>
            </span>
            <input type="file" id="file" accept=".txt">
          </label>
          <div class="row">
            <button type="button" id="parse" commandfor="app" command="--parse">좌표 추출</button>
            <button type="button" id="start" commandfor="app" command="--start" disabled>조회 시작</button>
            <button type="button" id="pause" commandfor="app" command="--pause" disabled>일시정지</button>
            <button type="button" id="resume" commandfor="app" command="--resume" disabled>재개</button>
            <button type="button" id="stop" commandfor="app" command="--stop" disabled>중지</button>
            <button type="button" id="export" commandfor="app" command="--export" disabled>CSV 내보내기</button>
          </div>
        </fieldset>
      </form>
      <div>
        <span class="caps" id="coords-label">추출된 좌표 (lat,lon)</span>
        <pre id="coords" class="coords-view" role="region" aria-labelledby="coords-label" tabindex="-1"><span
            class="coords-placeholder" aria-hidden="true">좌표가 이곳에 표시됩니다.</span><code
            class="coords-content"></code></pre>
      </div>
      <div class="row-progress">
        <div class="sp">
          <label class="caps" id="prog-label" for="prog">진행 상황 0%</label>
          <div id="prog-shell" class="progress-shell">
            <progress id="prog" value="0" max="100"></progress>
            <div class="progress-visual">
              <div class="progress-fill"></div>
            </div>
          </div>
        </div>
        <output id="counts">총 <strong id="cnt-total">0</strong>건 중
          <strong id="cnt-success">0</strong>건 완료,<br><strong id="cnt-fail">0</strong>건 실패, <strong
            id="cnt-remain">0</strong>건 미처리</output>
      </div>
      <output id="status" class="status" role="status"></output>
      <footer>
        <p>• 품질을 위해 속도는 초당 1회로 제한됩니다.</p>
      </footer>
    </section>
    <div class="card-stack">
      <div class="card-stack-spotlight"></div>
      <div class="card-stack-content">
        <section class="card card-stack-top no-spotlight">
          <header class="card-header">
            <h2>결과 표</h2>
            <p class="header-desc">좌표별 주소 및 지도 링크</p>
          </header>
          <search>
            <form class="filters">
              <input id="filter-q" type="search" inputmode="search" enterkeyhint="search" placeholder="전체검색"
                aria-label="전체검색">
              <select id="filter-kind" aria-label="구분">
                <option value="">구분(전체)</option>
                <option value="kr">KR</option>
                <option value="kp">KP</option>
                <option value="world">WORLD</option>
                <option value="에러">에러</option>
              </select>
              <input id="filter-sido" type="search" inputmode="search" enterkeyhint="search" placeholder="시·도"
                aria-label="시·도">
              <input id="filter-sigungu" type="search" inputmode="search" enterkeyhint="search" placeholder="시·군·구"
                aria-label="시·군·구">
              <input id="filter-emd" type="search" inputmode="search" enterkeyhint="search" placeholder="읍·면·동·리"
                aria-label="읍·면·동·리">
              <input id="filter-tag" type="search" inputmode="search" enterkeyhint="search" placeholder="지물 태그"
                aria-label="지물 태그">
              <input id="filter-fulladdr" type="search" inputmode="search" enterkeyhint="search" placeholder="전체주소"
                aria-label="전체주소">
              <button type="button" id="filter-clear" commandfor="app" command="--filter-clear">필터 초기화</button>
            </form>
          </search>
        </section>
        <section class="card card-stack-bottom no-spotlight">
          <div class="table-wrap">
            <p class="table-hint empty-hint" aria-live="polite" aria-atomic="true">
              random_data.txt 파일을 업로드해 주세요.
            </p>
            <p class="table-hint filter-empty-hint" aria-live="polite" aria-atomic="true">
              필터 결과가 없습니다.
            </p>
            <table id="tbl">
              <caption class="sr-only">
                역지오코딩 결과 표
              </caption>
              <thead>
                <tr>
                  <th data-col-key="kind">구분</th>
                  <th data-col-key="idx">순번</th>
                  <th data-col-key="coords">좌표 (위도,경도)</th>
                  <th data-col-key="sido">시·도</th>
                  <th data-col-key="sigungu">시·군·구</th>
                  <th data-col-key="emd">읍·면·동·리</th>
                  <th data-col-key="tag">지물 태그</th>
                  <th data-col-key="fullAddr">전체주소</th>
                  <th data-col-key="maps">지도링크</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </section>
      </div>
    </div>
  </main>
  <div id="map-popover" popover="auto" class="map-popover" role="dialog" aria-label="지도 링크" tabindex="-1">
    <div class="map-links" id="map-popover-links">
      <a data-provider-key="Google" href="about:blank" data-url-template="https://www.google.com/maps?q={lat},{lon}"
        target="_blank" rel="noopener noreferrer">Google</a>
      <a data-provider-key="OSM" href="about:blank"
        data-url-template="https://www.openstreetmap.org/search?query={lat},{lon}&zoom=16#map=16/{lat}/{lon}"
        target="_blank" rel="noopener noreferrer">OSM</a>
      <a data-provider-key="Naver" href="about:blank"
        data-url-template="https://map.naver.com/?lng={lon}&lat={lat}&title={lat}%2C%20{lon}" target="_blank"
        rel="noopener noreferrer">Naver</a>
      <a data-provider-key="Kakao" href="about:blank"
        data-url-template="https://map.kakao.com/link/map/{lat}%20{lon},{lat},{lon}" target="_blank"
        rel="noopener noreferrer">Kakao</a>
    </div>
  </div>
  <template id="tmpl-row-skeleton">
    <tr>
      <td data-label="구분">
        <div class="skeleton-bar"></div>
      </td>
      <td data-label="순번"></td>
      <td data-label="좌표 (위도,경도)">
        <div class="skeleton-bar"></div>
      </td>
      <td data-label="시·도">
        <div class="skeleton-bar"></div>
      </td>
      <td data-label="시·군·구">
        <div class="skeleton-bar"></div>
      </td>
      <td data-label="읍·면·동·리">
        <div class="skeleton-bar"></div>
      </td>
      <td data-label="지물 태그">
        <div class="skeleton-bar"></div>
      </td>
      <td data-label="전체주소">
        <div class="skeleton-bar"></div>
      </td>
      <td data-label="지도링크">
        <div class="skeleton-bar"></div>
        <button type="button" class="map-btn" aria-haspopup="dialog" commandfor="map-popover" command="show-popover"
          disabled>지도</button>
      </td>
    </tr>
  </template>
  <template id="tmpl-row">
    <tr>
      <td data-label="구분"></td>
      <td data-label="순번"></td>
      <td data-label="좌표 (위도,경도)"></td>
      <td data-label="시·도"></td>
      <td data-label="시·군·구"></td>
      <td data-label="읍·면·동·리"></td>
      <td data-label="지물 태그"></td>
      <td data-label="전체주소"></td>
      <td data-label="지도링크">
        <button type="button" class="map-btn" aria-haspopup="dialog" commandfor="map-popover" command="show-popover"
          disabled>지도</button>
      </td>
    </tr>
  </template>
  <noscript>이 도구는 자바스크립트가 필요합니다.</noscript>
  <script type="module">
    const COORD_REGEX =
      /(대한민국|세계)\s*위경도\s*[:：]\s*([+-]?\d+(?:\.\d+)?)\s*[,，]\s*([+-]?\d+(?:\.\d+)?)/g;
    const CC_SI = "시".charCodeAt(0);
    const CC_GUN = "군".charCodeAt(0);
    const CC_GU = "구".charCodeAt(0);
    const CC_EUP = "읍".charCodeAt(0);
    const CC_MYEON = "면".charCodeAt(0);
    const CC_DONG = "동".charCodeAt(0);
    const CC_RI = "리".charCodeAt(0);
    const RX_STAMP = /[:.]/g;
    const RX_FILE_EXT = /\.[^.]+$/;
    const RX_SIGUNGU_STRIP_CACHE = new Map();
    const csvEsc = (s) => {
      s = String(s ?? "");
      if (s) {
        const c0 = s.charCodeAt(0);
        if (c0 === 9 || c0 === 61 || c0 === 43 || c0 === 45 || c0 === 64) {
          s = "'" + s;
        }
      }
      let needsQuote = false;
      for (let i = 0; i < s.length; i++) {
        const c = s.charCodeAt(i);
        if (c === 34) {
          s = s.replaceAll('"', '""');
          return `"${s}"`;
        }
        if (!needsQuote && (c === 44 || c === 10 || c === 13)) needsQuote = true;
      }
      return needsQuote ? `"${s}"` : s;
    };
    const lower = (s) => String(s || "").toLowerCase();
    const CONFIG = {
      MAX_RETRY: 3,
      REQUEST_TIMEOUT_MS: 10_000,
      RATE_LIMIT_DELAY_MS: 1_000,
      REVERSE_ZOOM: 14,
      SPECIAL_CITIES: /서울|부산|대구|인천|광주|대전|울산|세종/,
      BIG_MODE_THRESHOLD: 1000,
    };
    const EVT_CAPTURE = { capture: true };
    const EVT_CAPTURE_PASSIVE = { capture: true, passive: true };
    const EVT_ONCE = { once: true };
    const FETCH_HEADERS = { Accept: "application/json" };
    const BASE_URL_HREF =
      `https://nominatim.openstreetmap.org/reverse?format=geocodejson&zoom=${CONFIG.REVERSE_ZOOM}&accept-language=ko`;
    function isCountryLike(name, lowerCountryName, lowerAdminCountry) {
      const l = lower(name);
      return !!l && (l === lowerCountryName || l === lowerAdminCountry);
    }
    const mapPopover = document.getElementById("map-popover");
    let MAP_POPOVER_OPEN = false;
    const mapAnchors =
      document.querySelectorAll("#map-popover-links a[data-url-template]");
    const MAP_PROVIDER_COUNT = mapAnchors.length;
    const MAP_LINKS = new Array(MAP_PROVIDER_COUNT);
    let mapHasRound6 = false;
    const RX_MAP_TOKEN = /{lat}|{lon}/g;
    for (let i = 0; i < MAP_PROVIDER_COUNT; i++) {
      const a = mapAnchors[i];
      const key = a.dataset.providerKey || "";
      const template = a.dataset.urlTemplate || "";
      RX_MAP_TOKEN.lastIndex = 0;
      const parts = [];
      let last = 0;
      for (let m; (m = RX_MAP_TOKEN.exec(template));) {
        const idx = m.index;
        if (idx > last) parts.push(template.slice(last, idx));
        parts.push(m[0] === "{lat}" ? 0 : 1);
        last = idx + m[0].length;
      }
      if (last < template.length) parts.push(template.slice(last));
      const round6 = key === "Naver";
      if (round6) mapHasRound6 = true;
      let build;
      if (parts.length === 4) {
        const p0 = parts[0];
        const t1 = parts[1];
        const p2 = parts[2];
        const t3 = parts[3];
        build = round6
          ? (lat, lon, lat6, lon6) =>
            p0 + (t1 === 0 ? lat6 : lon6) + p2 + (t3 === 0 ? lat6 : lon6)
          : (lat, lon) =>
            p0 + (t1 === 0 ? lat : lon) + p2 + (t3 === 0 ? lat : lon);
      } else if (parts.length === 8) {
        const p0 = parts[0];
        const t1 = parts[1];
        const p2 = parts[2];
        const t3 = parts[3];
        const p4 = parts[4];
        const t5 = parts[5];
        const p6 = parts[6];
        const t7 = parts[7];
        build = round6
          ? (lat, lon, lat6, lon6) =>
            p0 +
            (t1 === 0 ? lat6 : lon6) +
            p2 +
            (t3 === 0 ? lat6 : lon6) +
            p4 +
            (t5 === 0 ? lat6 : lon6) +
            p6 +
            (t7 === 0 ? lat6 : lon6)
          : (lat, lon) =>
            p0 +
            (t1 === 0 ? lat : lon) +
            p2 +
            (t3 === 0 ? lat : lon) +
            p4 +
            (t5 === 0 ? lat : lon) +
            p6 +
            (t7 === 0 ? lat : lon);
      } else {
        build = round6
          ? (lat, lon, lat6, lon6) => {
            lat = lat6;
            lon = lon6;
            let out = "";
            for (let i = 0; i < parts.length; i++) {
              const p = parts[i];
              out += p === 0 ? lat : p === 1 ? lon : p;
            }
            return out;
          }
          : (lat, lon) => {
            let out = "";
            for (let i = 0; i < parts.length; i++) {
              const p = parts[i];
              out += p === 0 ? lat : p === 1 ? lon : p;
            }
            return out;
          };
      }
      MAP_LINKS[i] = {
        key,
        build,
      };
    }
    const MAP_HAS_ROUND6 = mapHasRound6;
    let LAST_MAP_INVOKER = null;
    let MAP_POPOVER_PREV_FOCUS = null;
    document.addEventListener("command", (e) => {
      if (e.command !== "show-popover") return;
      const btn = e.source?.closest?.("button.map-btn");
      if (!btn) return;
      const prevInvoker = LAST_MAP_INVOKER;
      LAST_MAP_INVOKER = btn;
      if (!MAP_POPOVER_OPEN || prevInvoker === btn) return;
      MAP_POPOVER_PREV_FOCUS = btn;
      updateMapPopoverFromInvoker(btn);
    }, EVT_CAPTURE);
    function updateMapPopoverFromInvoker(invoker) {
      const idxStr = invoker.dataset.idx;
      if (!idxStr) return;
      const r = AppState.records[idxStr | 0];
      if (!r) return;
      const lat = r.latStr;
      const lon = r.lonStr;
      if (!lat || !lon) return;
      let lat6 = null;
      let lon6 = null;
      if (MAP_HAS_ROUND6) {
        lat6 = r.lat6;
        if (lat6 == null) r.lat6 = lat6 = fmtCoord6(lat);
        lon6 = r.lon6;
        if (lon6 == null) r.lon6 = lon6 = fmtCoord6(lon);
      }
      for (let i = 0; i < MAP_PROVIDER_COUNT; i++) {
        mapAnchors[i].href = MAP_LINKS[i].build(lat, lon, lat6, lon6);
      }
    }
    function closeMapPopover() {
      if (!MAP_POPOVER_OPEN) return;
      MAP_POPOVER_OPEN = false;
      mapPopover.hidePopover();
    }
    mapPopover.addEventListener("toggle", (e) => {
      MAP_POPOVER_OPEN = e.newState === "open";
      if (!MAP_POPOVER_OPEN) {
        if (MAP_POPOVER_PREV_FOCUS) {
          const active = document.activeElement;
          if (
            (active === document.body || mapPopover.contains(active)) &&
            MAP_POPOVER_PREV_FOCUS.isConnected
          ) {
            MAP_POPOVER_PREV_FOCUS.focus();
          }
        }
        MAP_POPOVER_PREV_FOCUS = null;
        LAST_MAP_INVOKER = null;
        return;
      }
      MAP_POPOVER_PREV_FOCUS =
        document.activeElement instanceof HTMLElement ? document.activeElement : LAST_MAP_INVOKER;
      const invoker = LAST_MAP_INVOKER;
      if (!invoker || !invoker.isConnected) return;
      updateMapPopoverFromInvoker(invoker);
    });
    const fmt = new Intl.NumberFormat("ko-KR", { maximumFractionDigits: 0 }).format;
    const COORD_DECIMALS = 6;
    const COORD_POW = 10 ** COORD_DECIMALS;
    const COORD_INV_POW = 1 / COORD_POW;
    const fmtCoord6 = (v) => {
      if (typeof v === "string") {
        const s0 = v;
        if (!s0) return "";
        const dot = s0.indexOf(".");
        if (dot === -1) return s0;
        if (s0.indexOf("e") === -1 && s0.indexOf("E") === -1) {
          const fracLen = s0.length - dot - 1;
          if (fracLen <= COORD_DECIMALS) {
            let end = s0.length;
            while (end && s0.charCodeAt(end - 1) === 48) end--;
            if (end && s0.charCodeAt(end - 1) === 46) end--;
            return end === s0.length ? s0 : s0.slice(0, end);
          }
        }
      }
      const n = (typeof v === "number") ? v : Number(v);
      if (!Number.isFinite(n)) return String(v ?? "");
      let s = (Math.round(n * COORD_POW) * COORD_INV_POW).toFixed(COORD_DECIMALS);
      let end = s.length;
      while (end && s.charCodeAt(end - 1) === 48) end--;
      if (end && s.charCodeAt(end - 1) === 46) end--;
      return end === s.length ? s : s.slice(0, end);
    };
    const tbl = document.getElementById("tbl");
    const domElements = {
      file: document.getElementById("file"),
      dropZone: document.querySelector(".drop-zone"),
      themeToggle: document.getElementById("theme-toggle"),
      themeToggleLabel: document.getElementById("theme-toggle-label"),
      app: document.getElementById("app"),
      exportBtn: document.getElementById("export"),
      status: document.getElementById("status"),
      cntTotal: document.getElementById("cnt-total"),
      cntSuccess: document.getElementById("cnt-success"),
      cntFail: document.getElementById("cnt-fail"),
      cntRemain: document.getElementById("cnt-remain"),
      progShell: document.getElementById("prog-shell"),
      prog: document.getElementById("prog"),
      progLabel: document.getElementById("prog-label"),
      tableWrap: document.querySelector(".table-wrap"),
      emptyHint: document.querySelector(".table-wrap .empty-hint"),
      tbody: tbl.tBodies[0],
      coords: document.getElementById("coords"),
      coordsContent: document.querySelector("#coords .coords-content"),
      filterQ: document.getElementById("filter-q"),
      filterKind: document.getElementById("filter-kind"),
      filterSido: document.getElementById("filter-sido"),
      filterSigungu: document.getElementById("filter-sigungu"),
      filterEmd: document.getElementById("filter-emd"),
      filterTag: document.getElementById("filter-tag"),
      filterFullAddr: document.getElementById("filter-fulladdr"),
      filtersForm: document.querySelector(".filters"),
    };
    const setCoordsText = (text) => {
      domElements.coordsContent.textContent = text;
      const hasContent = text.length > 0;
      domElements.coords.toggleAttribute("data-has-content", hasContent);
      if (!hasContent) {
        clearScrollShadowState(domElements.coords);
        return;
      }
      requestScrollShadowSync(domElements.coords);
    };
    const parseBtn = document.getElementById("parse");
    const startBtn = document.getElementById("start");
    const pauseBtn = document.getElementById("pause");
    const resumeBtn = document.getElementById("resume");
    const stopBtn = document.getElementById("stop");
    const root = document.documentElement;
    const PERF_MODE_ATTR = "data-perf-mode";
    const DROP_ZONE_FILE_LABELS = document.querySelectorAll(
      ".drop-text .desktop-msg, .drop-text .mobile-msg"
    );
    const THEME_STORAGE_KEY = "srg-theme";
    const themeMedia = window.matchMedia("(prefers-color-scheme: dark)");
    const getStoredTheme = () => {
      try {
        const stored = localStorage.getItem(THEME_STORAGE_KEY);
        return stored === "light" || stored === "dark" ? stored : null;
      } catch {
        return null;
      }
    };
    const applyTheme = (theme) => {
      root.dataset.theme = theme;
      const label = theme === "dark" ? "라이트 모드" : "다크 모드";
      domElements.themeToggleLabel.textContent = label;
      domElements.themeToggle.setAttribute("aria-label", `${label}로 전환`);
      domElements.themeToggle.setAttribute("title", `${label}로 전환`);
      domElements.themeToggle.setAttribute("aria-pressed", String(theme === "dark"));
    };
    const getSystemTheme = () => (themeMedia.matches ? "dark" : "light");
    applyTheme(getStoredTheme() ?? getSystemTheme());
    themeMedia.addEventListener("change", () => {
      if (getStoredTheme()) return;
      applyTheme(getSystemTheme());
    });
    domElements.themeToggle.addEventListener("click", () => {
      const next = root.dataset.theme === "dark" ? "light" : "dark";
      try {
        localStorage.setItem(THEME_STORAGE_KEY, next);
      } catch {
      }
      applyTheme(next);
    });
    const updateTableHeadOffset = (() => {
      let lastHeight = -1;
      const wrap = domElements.tableWrap;
      const tHead = tbl.tHead;
      return () => {
        const height = tHead.offsetHeight;
        if (height === lastHeight) return;
        lastHeight = height;
        wrap.style.setProperty("--table-head-offset", `${height}px`);
      };
    })();
    updateTableHeadOffset();
    function syncLayoutMetrics() {
      updateTableHeadOffset();
      const wrap = domElements.tableWrap;
      if (RENDER_CACHE.hasResults) requestScrollShadowSync(wrap);
      const coords = domElements.coords;
      if (coords.hasAttribute("data-has-content")) requestScrollShadowSync(coords);
    }
    const SHADOW_SYNC_PENDING = new WeakSet();
    function clearScrollShadowState(el) {
      SHADOW_SYNC_PENDING.delete(el);
      if (!(el instanceof HTMLElement)) return;
      el.removeAttribute("data-at-top");
      el.removeAttribute("data-at-bottom");
      el.removeAttribute("data-shadow-rebind");
    }
    function requestScrollShadowSync(el) {
      if (!(el instanceof HTMLElement)) return;
      if (SHADOW_SYNC_PENDING.has(el)) return;
      SHADOW_SYNC_PENDING.add(el);
      requestAnimationFrame(() => {
        SHADOW_SYNC_PENDING.delete(el);
        if (el.scrollHeight - el.clientHeight > 1) {
          el.removeAttribute("data-at-top");
          el.removeAttribute("data-at-bottom");
        } else {
          el.setAttribute("data-at-top", "");
          el.setAttribute("data-at-bottom", "");
        }
      });
    }
    function rebindScrollShadowTimeline(el) {
      if (!(el instanceof HTMLElement)) return;
      el.setAttribute("data-shadow-rebind", "");
      requestAnimationFrame(() => {
        el.removeAttribute("data-shadow-rebind");
        requestScrollShadowSync(el);
      });
    }
    clearScrollShadowState(domElements.tableWrap);
    clearScrollShadowState(domElements.coords);
    let SCROLL_ACTIVE = false;
    let SCROLL_LAST_TS = 0;
    let SCROLL_IDLE_RAF = 0;
    const SCROLL_IDLE_MS = 120;
    const setGlobalScrolling = (on) => {
      root.classList.toggle("scrolling", on);
    };
    const resetScrollState = () => {
      setGlobalScrolling(false);
      SCROLL_ACTIVE = false;
      SCROLL_LAST_TS = 0;
      if (SCROLL_IDLE_RAF) {
        cancelAnimationFrame(SCROLL_IDLE_RAF);
        SCROLL_IDLE_RAF = 0;
      }
    };
    const checkScrollIdle = () => {
      if (!SCROLL_ACTIVE) {
        SCROLL_IDLE_RAF = 0;
        return;
      }
      if (performance.now() - SCROLL_LAST_TS >= SCROLL_IDLE_MS) {
        SCROLL_IDLE_RAF = 0;
        SCROLL_ACTIVE = false;
        if (FIND_REVEAL_ACTIVE) bumpFindRehideTimer();
        setGlobalScrolling(false);
        return;
      }
      SCROLL_IDLE_RAF = requestAnimationFrame(checkScrollIdle);
    };
    const KIND_COL_INDEX = 0;
    const IDX_COL_INDEX = 1;
    const COORDS_COL_INDEX = 2;
    const SIDO_COL_INDEX = 3;
    const SIGUNGU_COL_INDEX = 4;
    const EMD_COL_INDEX = 5;
    const TAG_COL_INDEX = 6;
    const FULLADDR_COL_INDEX = 7;
    const MAPS_COL_INDEX = 8;
    const SKELETON_TEMPLATE =
      document.getElementById("tmpl-row-skeleton").content.querySelector("tr");
    const ROW_TEMPLATE =
      document.getElementById("tmpl-row").content.querySelector("tr");
    const RX_COMMA_WS = /\s*,\s*/g;
    const RX_WS = /\s+/g;
    const norm = (s) => {
      if (s == null) return "";
      if (typeof s !== "string") s = String(s);
      s = s.trim();
      if (!s) return "";
      s = s.toLowerCase();
      return s.indexOf(",") !== -1 ? s.replace(RX_COMMA_WS, ",") : s;
    };
    const HIDDEN_UNTIL_FOUND = "until-found";
    let FIND_REHIDE_TIMER = null;
    let FIND_REVEAL_ACTIVE = false;
    const FIND_REVEALED_ROWS = new Set();
    function unhideUntilFoundRows() {
      const rows = domElements.tbody.rows;
      for (let i = 0; i < rows.length; i++) {
        const tr = rows[i];
        if (tr.hidden) tr.removeAttribute("hidden");
      }
    }
    function bumpFindRehideTimer() {
      if (FIND_REHIDE_TIMER) clearTimeout(FIND_REHIDE_TIMER);
      FIND_REHIDE_TIMER = setTimeout(() => {
        clearFindReveals();
        const f = getLiveFilterSnapshot();
        if (f.active) {
          startChunkedFilterApply(f);
          return;
        }
        unhideUntilFoundRows();
      }, 8000);
    }
    function buildFilterSnapshot() {
      let q = norm(domElements.filterQ.value);
      const kind = domElements.filterKind.value;
      const sido = norm(domElements.filterSido.value);
      const sigungu = norm(domElements.filterSigungu.value);
      const emd = norm(domElements.filterEmd.value);
      const tag = norm(domElements.filterTag.value);
      const fullAddr = norm(domElements.filterFullAddr.value);
      let qMode = 0;
      let q1 = "";
      let qTokens = null;
      if (q) {
        const pipe = q.indexOf("|");
        if (pipe !== -1) {
          qMode = 2;
          let toks = null;
          let start = 0;
          while (true) {
            const end = q.indexOf("|", start);
            const seg = (end === -1 ? q.slice(start) : q.slice(start, end)).trim();
            if (seg) (toks ??= []).push(seg);
            if (end === -1) break;
            start = end + 1;
          }
          if (!toks) {
            q = "";
            qMode = 0;
          } else if (toks.length === 1) {
            qMode = 1;
            q1 = toks[0];
            qTokens = null;
          } else {
            qTokens = toks;
          }
        } else {
          qMode = 1;
          const s = q;
          const n = s.length;
          let start = -1;
          let toks = null;
          for (let i = 0; i <= n; i++) {
            const c = i < n ? s.charCodeAt(i) : 32;
            if (c <= 32) {
              if (start !== -1) {
                const t = s.slice(start, i);
                if (toks) toks.push(t);
                else q1 = t;
                start = -1;
              }
            } else if (start === -1) {
              if (!toks && q1) {
                toks = [q1];
                q1 = "";
              }
              start = i;
            }
          }
          if (toks) {
            if (toks.length === 1) {
              q1 = toks[0];
              qTokens = null;
            } else {
              qTokens = toks;
            }
          } else if (!q1) {
            q = "";
            qMode = 0;
          }
        }
      }
      if (qTokens && qTokens.length > 1) {
        let hasDup = false;
        outer: for (let i = 1; i < qTokens.length; i++) {
          const t = qTokens[i];
          for (let j = 0; j < i; j++) {
            if (qTokens[j] === t) {
              hasDup = true;
              break outer;
            }
          }
        }
        if (hasDup) {
          const out = [];
          for (let i = 0; i < qTokens.length; i++) {
            const t = qTokens[i];
            let dup = false;
            for (let j = 0; j < out.length; j++) {
              if (out[j] === t) {
                dup = true;
                break;
              }
            }
            if (!dup) out.push(t);
          }
          qTokens = out;
        }
        if (qTokens.length === 1) {
          qMode = 1;
          q1 = qTokens[0];
          qTokens = null;
        } else if (qMode !== 2) {
          qTokens.sort((a, b) => b.length - a.length);
        }
      }
      let qTest = null;
      if (qMode) {
        if (!qTokens) {
          const needle = q1;
          qTest = (r) => getQSearch(r).indexOf(needle) !== -1;
        } else if (qMode === 2) {
          const needles = qTokens;
          qTest = (r) => {
            const hay = getQSearch(r);
            for (let i = 0; i < needles.length; i++) {
              if (hay.indexOf(needles[i]) !== -1) return true;
            }
            return false;
          };
        } else {
          const needles = qTokens;
          qTest = (r) => {
            const hay = getQSearch(r);
            for (let i = 0; i < needles.length; i++) {
              if (hay.indexOf(needles[i]) === -1) return false;
            }
            return true;
          };
        }
      }
      const active = !!(kind || sido || sigungu || emd || tag || fullAddr || qTest);
      if (!active) return { active: false };
      return {
        active: true,
        kind,
        sido,
        sigungu,
        emd,
        tag,
        fullAddr,
        qTest,
      };
    }
    let FILTER_SNAP = buildFilterSnapshot();
    let filterDirty = false;
    function getLiveFilterSnapshot() {
      if (filterDirty) {
        FILTER_SNAP = buildFilterSnapshot();
        filterDirty = false;
      }
      return FILTER_SNAP;
    }
    const Q_SEARCH_SEP = "\u0000";
    const getQSearch = (r) => {
      let s = r._q;
      if (s != null) return s;
      return (r._q =
        r._f_fullAddr +
        Q_SEARCH_SEP +
        r._f_tag +
        Q_SEARCH_SEP +
        r._f_emd +
        Q_SEARCH_SEP +
        r._f_sigungu +
        Q_SEARCH_SEP +
        r._f_sido +
        Q_SEARCH_SEP +
        r.latStr +
        "," +
        r.lonStr);
    };
    function setRowHiddenByFilterActive(tr, wasHidden, f, r) {
      if (FIND_REVEALED_ROWS.has(tr)) {
        if (wasHidden) tr.removeAttribute("hidden");
        return false;
      }
      return setRowHiddenByFilterActiveNoReveal(tr, wasHidden, f, r);
    }
    function setRowHiddenByFilterActiveNoReveal(tr, wasHidden, f, r) {
      if (!r || r._f_kind === undefined) {
        if (!wasHidden) tr.setAttribute("hidden", HIDDEN_UNTIL_FOUND);
        return true;
      }
      const kind = f.kind;
      const sido = f.sido;
      const sigungu = f.sigungu;
      const emd = f.emd;
      const tag = f.tag;
      const fullAddr = f.fullAddr;
      const qTest = f.qTest;
      let hide = false;
      if (kind && r._f_kind !== kind) {
        hide = true;
      } else if (sido && r._f_sido.indexOf(sido) === -1) {
        hide = true;
      } else if (sigungu && r._f_sigungu.indexOf(sigungu) === -1) {
        hide = true;
      } else if (emd && r._f_emd.indexOf(emd) === -1) {
        hide = true;
      } else if (tag && r._f_tag.indexOf(tag) === -1) {
        hide = true;
      } else if (fullAddr && r._f_fullAddr.indexOf(fullAddr) === -1) {
        hide = true;
      } else if (qTest && !qTest(r)) {
        hide = true;
      }
      if (hide) {
        if (!wasHidden) tr.setAttribute("hidden", HIDDEN_UNTIL_FOUND);
        return true;
      }
      if (wasHidden) tr.removeAttribute("hidden");
      return false;
    }
    let setHiddenByFilterActiveFn = setRowHiddenByFilterActiveNoReveal;
    function clearFindReveals() {
      if (!FIND_REVEAL_ACTIVE && !FIND_REHIDE_TIMER) return;
      FIND_REVEAL_ACTIVE = false;
      setHiddenByFilterActiveFn = setRowHiddenByFilterActiveNoReveal;
      if (FIND_REHIDE_TIMER) clearTimeout(FIND_REHIDE_TIMER);
      FIND_REHIDE_TIMER = null;
      FIND_REVEALED_ROWS.clear();
    }
    const FILTER_CTX = {
      timer: null,
      job: null,
    };
    function cancelPendingFilterDebounce() {
      if (FILTER_CTX.timer) {
        clearTimeout(FILTER_CTX.timer);
        FILTER_CTX.timer = null;
      }
    }
    function cancelActiveFilterApply() {
      const job = FILTER_CTX.job;
      if (!job) return;
      if (job.raf) {
        cancelAnimationFrame(job.raf);
        job.raf = 0;
      }
      FILTER_CTX.job = null;
    }
    function cancelActiveFilterTask() {
      cancelPendingFilterDebounce();
      cancelActiveFilterApply();
    }
    function startChunkedFilterApply(f = getLiveFilterSnapshot()) {
      const rows = domElements.tbody.rows;
      const len = rows.length;
      if (len === 0) {
        cancelActiveFilterApply();
        syncFilterEmptyUI(f.active, 0, false);
        return;
      }
      if (!f.active) {
        cancelActiveFilterApply();
        unhideUntilFoundRows();
        syncFilterEmptyUI(false, len, true);
        return;
      }
      const records = AppState.records;
      const setHidden = setHiddenByFilterActiveFn;
      if (len <= 2000) {
        cancelActiveFilterApply();
        let anyVisible = false;
        for (let i = 0; i < len; i++) {
          const tr = rows[i];
          const wasHidden = tr.hidden;
          if (!setHidden(tr, wasHidden, f, records[i])) anyVisible = true;
        }
        syncFilterEmptyUI(true, len, anyVisible);
        return;
      }
      const existing = FILTER_CTX.job;
      if (existing && existing.rows === rows) {
        existing.f = f;
        existing.i = 0;
        existing.len = len;
        existing.records = records;
        existing.anyVisible = false;
        if (!existing.raf) existing.raf = requestAnimationFrame(existing.step);
        return;
      }
      cancelActiveFilterApply();
      const job = {
        raf: 0,
        i: 0,
        rows,
        len,
        f,
        records,
        anyVisible: false,
        step: () => {
          if (FILTER_CTX.job !== job) return;
          job.raf = 0;
          const rows = job.rows;
          const records = job.records;
          const fNow = job.f;
          const len = job.len;
          let i = job.i;
          let anyVisible = job.anyVisible;
          const setHidden = setHiddenByFilterActiveFn;
          const deadline = performance.now() + 8;
          let processed = 0;
          while (i < len) {
            const tr = rows[i];
            const wasHidden = tr.hidden;
            if (!setHidden(tr, wasHidden, fNow, records[i])) anyVisible = true;
            i++;
            processed++;
            if (processed >= 1500) break;
            if ((processed & 7) === 0 && performance.now() >= deadline) break;
          }
          job.i = i;
          job.anyVisible = anyVisible;
          if (i < len) {
            job.raf = requestAnimationFrame(job.step);
          } else {
            syncFilterEmptyUI(true, len, anyVisible);
            FILTER_CTX.job = null;
          }
        },
      };
      FILTER_CTX.job = job;
      job.raf = requestAnimationFrame(job.step);
    }
    function scheduleApplyFilterAll() {
      filterDirty = true;
      const activeJob = FILTER_CTX.job;
      if (activeJob) {
        activeJob.i = activeJob.len;
        if (activeJob.raf) {
          cancelAnimationFrame(activeJob.raf);
          activeJob.raf = 0;
        }
      }
      cancelPendingFilterDebounce();
      FILTER_CTX.timer = setTimeout(() => {
        FILTER_CTX.timer = null;
        if (MAP_POPOVER_OPEN) closeMapPopover();
        clearFindReveals();
        startChunkedFilterApply(getLiveFilterSnapshot());
      }, 120);
    }
    const CSV_ENCODER = new TextEncoder();
    const CSV_NL_BYTES = CSV_ENCODER.encode("\n");
    const CSV_HEADER_BYTES = (() => {
      let header = "\uFEFF";
      header += csvEsc("구분");
      header += "," + csvEsc("순번");
      header += "," + csvEsc("좌표 (위도,경도)");
      header += "," + csvEsc("시·도");
      header += "," + csvEsc("시·군·구");
      header += "," + csvEsc("읍·면·동·리");
      header += "," + csvEsc("지물 태그");
      header += "," + csvEsc("전체주소");
      for (let i = 0; i < MAP_PROVIDER_COUNT; i++) {
        header += "," + csvEsc("지도링크(" + MAP_LINKS[i].key + ")");
      }
      return CSV_ENCODER.encode(header);
    })();
    const AddressFormatter = {
      _getAdminFromGeocoding(gc, countryCode, p0, p1) {
        let level2 = "";
        let level4 = "";
        let level6 = "";
        let level7 = "";
        let level8 = "";
        let level9 = "";
        let level10 = "";
        const admin = gc.admin;
        if (admin && typeof admin === "object") {
          let filled = 0;
          for (const key in admin) {
            if (
              key.length < 6 ||
              key.charCodeAt(0) !== 108 ||
              key.charCodeAt(1) !== 101 ||
              key.charCodeAt(2) !== 118 ||
              key.charCodeAt(3) !== 101 ||
              key.charCodeAt(4) !== 108
            ) {
              continue;
            }
            let n = 0;
            for (let i = 5; i < key.length; i++) {
              const d = key.charCodeAt(i) - 48;
              if (d < 0 || d > 9) {
                n = 0;
                break;
              }
              n = n * 10 + d;
            }
            if (!n) continue;
            const val = admin[key];
            switch (n) {
              case 2:
                level2 = val;
                filled |= 1;
                break;
              case 4:
                level4 = val;
                filled |= 2;
                break;
              case 6:
                level6 = val;
                filled |= 4;
                break;
              case 7:
                level7 = val;
                filled |= 8;
                break;
              case 8:
                level8 = val;
                filled |= 16;
                break;
              case 9:
                level9 = val;
                filled |= 32;
                break;
              case 10:
                level10 = val;
                filled |= 64;
                break;
            }
            if (filled === 127) break;
          }
        }
        const adminCountry = level2 || "";
        const countryName = gc.country || adminCountry;
        let lowerCountryName = "";
        let lowerAdminCountry = "";
        let isKoreanPeninsula = false;
        if (
          countryCode === "kr" ||
          countryCode === "kp" ||
          countryName === "대한민국" ||
          countryName === "조선민주주의인민공화국"
        ) {
          isKoreanPeninsula = true;
        } else {
          lowerCountryName = lower(countryName);
          lowerAdminCountry = lower(adminCountry);
          isKoreanPeninsula =
            lowerCountryName.indexOf("korea") !== -1 ||
            lowerAdminCountry.indexOf("korea") !== -1;
        }
        let sido = "";
        let sigungu = "";
        let eupmyeon = "";
        const primaryName = gc.name || p0 || "";
        const cityDistrict = gc.city_district || gc.district || gc.suburb || "";
        const city = gc.city || "";
        const county = gc.county || "";
        if (isKoreanPeninsula) {
          const level6Kr = level6 || level7;
          const specialCities = CONFIG.SPECIAL_CITIES;
          sido = level4 || gc.state || "";
          let cityIsSpecial = false;
          let cityIsSpecialKnown = false;
          if (!sido && city) {
            cityIsSpecialKnown = true;
            cityIsSpecial = specialCities.test(city);
            if (cityIsSpecial) {
              sido = city;
            }
          }
          let sidoIsSpecial = false;
          if (sido) {
            if (sido === city) {
              if (!cityIsSpecialKnown && city) {
                cityIsSpecialKnown = true;
                cityIsSpecial = specialCities.test(city);
              }
              sidoIsSpecial = cityIsSpecial;
            } else {
              sidoIsSpecial = specialCities.test(sido);
            }
          }
          if (sidoIsSpecial) {
            let picked = "";
            const cd = cityDistrict;
            const l6 = level6Kr;
            const co = county;
            const pn = primaryName;
            let cdLast = 0;
            let l6Last = 0;
            let coLast = 0;
            let pnLast = 0;
            let p0Last = 0;
            let p1Last = 0;
            if (cd && cd !== sido) {
              cdLast = cd.charCodeAt(cd.length - 1);
              if (cdLast === CC_GU || cdLast === CC_GUN) picked = cd;
            }
            if (!picked && l6 && l6 !== sido) {
              l6Last = l6.charCodeAt(l6.length - 1);
              if (l6Last === CC_GU || l6Last === CC_GUN) picked = l6;
            }
            if (!picked && co && co !== sido) {
              coLast = co.charCodeAt(co.length - 1);
              if (coLast === CC_GU || coLast === CC_GUN) picked = co;
            }
            if (!picked && pn && pn !== sido) {
              pnLast = pn.charCodeAt(pn.length - 1);
              if (pnLast === CC_GU || pnLast === CC_GUN) picked = pn;
            }
            if (!picked && p0 && p0 !== sido) {
              p0Last = p0.charCodeAt(p0.length - 1);
              if (p0Last === CC_GU || p0Last === CC_GUN) picked = p0;
            }
            if (!picked && p1 && p1 !== sido) {
              p1Last = p1.charCodeAt(p1.length - 1);
              if (p1Last === CC_GU || p1Last === CC_GUN) picked = p1;
            }
            if (!picked) {
              if (
                cdLast === CC_SI ||
                l6Last === CC_SI ||
                coLast === CC_SI ||
                pnLast === CC_SI ||
                p0Last === CC_SI ||
                p1Last === CC_SI
              ) {
                const isSpecialCityName = (name) => {
                  if (!name) return false;
                  if (name === city) {
                    if (!cityIsSpecialKnown && city) {
                      cityIsSpecialKnown = true;
                      cityIsSpecial = specialCities.test(city);
                    }
                    return cityIsSpecial;
                  }
                  return specialCities.test(name);
                };
                if (cdLast === CC_SI && !isSpecialCityName(cd)) picked = cd;
                else if (l6Last === CC_SI && !isSpecialCityName(l6)) picked = l6;
                else if (coLast === CC_SI && !isSpecialCityName(co)) picked = co;
                else if (pnLast === CC_SI && !isSpecialCityName(pn)) picked = pn;
                else if (p0Last === CC_SI && !isSpecialCityName(p0)) picked = p0;
                else if (p1Last === CC_SI && !isSpecialCityName(p1)) picked = p1;
              }
            }
            sigungu = picked || "";
          } else {
            let cityLike = "";
            const l6 = level6Kr;
            const co = county;
            const pn = primaryName;
            let cityLast = 0;
            let coLast = 0;
            let l6Last = 0;
            let pnLast = 0;
            let p1Last = 0;
            let p0Last = 0;
            if (city && city !== sido) {
              cityLast = city.charCodeAt(city.length - 1);
              if (cityLast === CC_SI || cityLast === CC_GUN) cityLike = city;
            }
            if (!cityLike && co && co !== sido) {
              coLast = co.charCodeAt(co.length - 1);
              if (coLast === CC_SI || coLast === CC_GUN) cityLike = co;
            }
            if (!cityLike && l6 && l6 !== sido) {
              l6Last = l6.charCodeAt(l6.length - 1);
              if (l6Last === CC_SI || l6Last === CC_GUN) cityLike = l6;
            }
            if (!cityLike && pn && pn !== sido) {
              pnLast = pn.charCodeAt(pn.length - 1);
              if (pnLast === CC_SI || pnLast === CC_GUN) cityLike = pn;
            }
            if (!cityLike && p1 && p1 !== sido) {
              p1Last = p1.charCodeAt(p1.length - 1);
              if (p1Last === CC_SI || p1Last === CC_GUN) cityLike = p1;
            }
            if (!cityLike && p0 && p0 !== sido) {
              p0Last = p0.charCodeAt(p0.length - 1);
              if (p0Last === CC_SI || p0Last === CC_GUN) cityLike = p0;
            }
            let districtLike = "";
            const town = gc.town;
            const locality = gc.locality;
            const village = gc.village;
            let cdLast = 0;
            if (cityDistrict && cityDistrict !== cityLike && cityDistrict !== sido) {
              cdLast = cityDistrict.charCodeAt(cityDistrict.length - 1);
              if (cdLast === CC_GU) districtLike = cityDistrict;
            }
            if (
              !districtLike &&
              level8 &&
              level8 !== cityLike &&
              level8 !== sido &&
              level8.charCodeAt(level8.length - 1) === CC_GU
            ) {
              districtLike = level8;
            } else if (
              !districtLike &&
              level9 &&
              level9 !== cityLike &&
              level9 !== sido &&
              level9.charCodeAt(level9.length - 1) === CC_GU
            ) {
              districtLike = level9;
            } else if (
              !districtLike &&
              town &&
              town !== cityLike &&
              town !== sido &&
              town.charCodeAt(town.length - 1) === CC_GU
            ) {
              districtLike = town;
            } else if (
              !districtLike &&
              locality &&
              locality !== cityLike &&
              locality !== sido &&
              locality.charCodeAt(locality.length - 1) === CC_GU
            ) {
              districtLike = locality;
            } else if (
              !districtLike &&
              village &&
              village !== cityLike &&
              village !== sido &&
              village.charCodeAt(village.length - 1) === CC_GU
            ) {
              districtLike = village;
            }
            if (cityLike && districtLike && districtLike !== cityLike) {
              sigungu = `${cityLike} ${districtLike}`;
            } else {
              sigungu = cityLike || districtLike || "";
            }
            if (!sigungu) {
              if (coLast === CC_SI || coLast === CC_GU || coLast === CC_GUN) sigungu = co;
              else if (l6Last === CC_SI || l6Last === CC_GU || l6Last === CC_GUN) sigungu = l6;
              else if (cdLast === CC_SI || cdLast === CC_GU || cdLast === CC_GUN) sigungu = cityDistrict;
              else if (pnLast === CC_SI || pnLast === CC_GU || pnLast === CC_GUN) sigungu = pn;
              else if (p0Last === CC_SI || p0Last === CC_GU || p0Last === CC_GUN) sigungu = p0;
              else if (p1Last === CC_SI || p1Last === CC_GU || p1Last === CC_GUN) sigungu = p1;
            }
          }
          let emdOut = "";
          let emd0 = "";
          let emd1 = "";
          let emd2 = "";
          let emd3 = "";
          let emd4 = "";
          let emd5 = "";
          let emd6 = "";
          let emd7 = "";
          let emd8 = "";
          let emd9 = "";
          let emdCount = 0;
          for (let i = 0; i < 10; i++) {
            let n;
            switch (i) {
              case 0: n = level8; break;
              case 1: n = level9; break;
              case 2: n = level10; break;
              case 3: n = gc.town; break;
              case 4: n = gc.village; break;
              case 5: n = gc.locality; break;
              case 6: n = gc.suburb; break;
              case 7: n = primaryName; break;
              case 8: n = p0; break;
              case 9: n = p1; break;
            }
            if (!n || n === sido || n === sigungu) continue;
            let dup = false;
            switch (emdCount) {
              case 9: if (n === emd8) { dup = true; break; }
              case 8: if (n === emd7) { dup = true; break; }
              case 7: if (n === emd6) { dup = true; break; }
              case 6: if (n === emd5) { dup = true; break; }
              case 5: if (n === emd4) { dup = true; break; }
              case 4: if (n === emd3) { dup = true; break; }
              case 3: if (n === emd2) { dup = true; break; }
              case 2: if (n === emd1) { dup = true; break; }
              case 1: if (n === emd0) dup = true;
            }
            const lc = n.charCodeAt(n.length - 1);
            if (
              dup ||
              (lc !== CC_EUP && lc !== CC_MYEON && lc !== CC_DONG && lc !== CC_RI)
            ) {
              continue;
            }
            switch (emdCount++) {
              case 0: emd0 = n; break;
              case 1: emd1 = n; break;
              case 2: emd2 = n; break;
              case 3: emd3 = n; break;
              case 4: emd4 = n; break;
              case 5: emd5 = n; break;
              case 6: emd6 = n; break;
              case 7: emd7 = n; break;
              case 8: emd8 = n; break;
              case 9: emd9 = n; break;
            }
            emdOut = emdOut ? emdOut + " " + n : (typeof n === "string" ? n : String(n));
          }
          eupmyeon = emdOut;
        } else {
          const isCityOrCounty = gc.type === "city" || gc.type === "county";
          sido =
            level4 ||
            gc.state ||
            gc.region ||
            gc.province ||
            gc.county ||
            gc.city ||
            "";
          let cityLike = "";
          if (city && city !== sido) cityLike = city;
          else if (county && county !== sido) cityLike = county;
          else if (level6 && level6 !== sido) cityLike = level6;
          else if (level7 && level7 !== sido) cityLike = level7;
          else if (primaryName && primaryName !== sido) cityLike = primaryName;
          else if (p1 && p1 !== sido) cityLike = p1;
          else if (p0 && p0 !== sido) cityLike = p0;
          let districtLike = "";
          const town = gc.town;
          const locality = gc.locality;
          const village = gc.village;
          const suburb = gc.suburb;
          const neighbourhood = gc.neighbourhood;
          if (cityDistrict && cityDistrict !== cityLike && cityDistrict !== sido) districtLike = cityDistrict;
          else if (level8 && level8 !== cityLike && level8 !== sido) districtLike = level8;
          else if (level9 && level9 !== cityLike && level9 !== sido) districtLike = level9;
          else if (town && town !== cityLike && town !== sido) districtLike = town;
          else if (locality && locality !== cityLike && locality !== sido) districtLike = locality;
          else if (village && village !== cityLike && village !== sido) districtLike = village;
          else if (suburb && suburb !== cityLike && suburb !== sido) districtLike = suburb;
          else if (neighbourhood && neighbourhood !== cityLike && neighbourhood !== sido) districtLike = neighbourhood;
          if (cityLike && districtLike && cityLike !== districtLike) {
            sigungu = `${cityLike} ${districtLike}`;
          } else {
            sigungu =
              cityLike ||
              districtLike ||
              level6 ||
              level8 ||
              gc.city ||
              gc.town ||
              gc.county ||
              gc.district ||
              gc.municipality ||
              "";
          }
          if ((!sigungu || sigungu === sido) && isCityOrCounty) {
            sigungu = primaryName || gc.city || gc.county || "";
          }
          eupmyeon = "";
          const level10Local = level10;
          const quarter = gc.quarter;
          const hamlet = gc.hamlet;
          const township = gc.township;
          const residential = gc.residential;
          const gcName = gc.name;
          let cand = locality;
          if (cand && cand !== sido && cand !== cityLike && cand !== districtLike) eupmyeon = cand;
          else {
            cand = level10Local;
            if (cand && cand !== sido && cand !== cityLike && cand !== districtLike) eupmyeon = cand;
            else {
              cand = town;
              if (cand && cand !== sido && cand !== cityLike && cand !== districtLike) eupmyeon = cand;
              else {
                cand = village;
                if (cand && cand !== sido && cand !== cityLike && cand !== districtLike) eupmyeon = cand;
                else {
                  cand = suburb;
                  if (cand && cand !== sido && cand !== cityLike && cand !== districtLike) eupmyeon = cand;
                  else {
                    cand = neighbourhood;
                    if (cand && cand !== sido && cand !== cityLike && cand !== districtLike) eupmyeon = cand;
                    else {
                      cand = quarter;
                      if (cand && cand !== sido && cand !== cityLike && cand !== districtLike) eupmyeon = cand;
                      else {
                        cand = hamlet;
                        if (cand && cand !== sido && cand !== cityLike && cand !== districtLike) eupmyeon = cand;
                        else {
                          cand = township;
                          if (cand && cand !== sido && cand !== cityLike && cand !== districtLike) eupmyeon = cand;
                          else {
                            cand = residential;
                            if (cand && cand !== sido && cand !== cityLike && cand !== districtLike) eupmyeon = cand;
                            else {
                              cand = gcName;
                              if (cand && cand !== sido && cand !== cityLike && cand !== districtLike) eupmyeon = cand;
                              else {
                                cand = p0;
                                if (cand && cand !== sido && cand !== cityLike && cand !== districtLike) eupmyeon = cand;
                                else {
                                  cand = p1;
                                  if (cand && cand !== sido && cand !== cityLike && cand !== districtLike) eupmyeon = cand;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }

          if (eupmyeon && (eupmyeon === sigungu || eupmyeon === sido)) {
            eupmyeon = "";
          }
          if (eupmyeon && isCityOrCounty && eupmyeon === primaryName && eupmyeon === sigungu) {
            eupmyeon = "";
          }
          if (!eupmyeon && districtLike && districtLike !== sido) {
            eupmyeon = districtLike;
            if (sigungu) {
              let s = String(sigungu);
              const dl = String(districtLike);
              if (s === dl) {
                s = "";
              } else {
                const dlLen = dl.length;
                const cut = s.length - dlLen;
                if (cut > 0 && s.endsWith(dl) && s.charCodeAt(cut - 1) === 32) {
                  s = s.slice(0, cut - 1).trim();
                } else {
                  let rx = RX_SIGUNGU_STRIP_CACHE.get(dl);
                  if (!rx) {
                    if (RX_SIGUNGU_STRIP_CACHE.size > 4096) RX_SIGUNGU_STRIP_CACHE.clear();
                    const esc = RegExp.escape(dl);
                    rx = new RegExp(`(?:^|\\s+)${esc}(?:\\s+|$)`, "g");
                    RX_SIGUNGU_STRIP_CACHE.set(dl, rx);
                  }
                  rx.lastIndex = 0;
                  s = s
                    .replace(rx, " ")
                    .replace(RX_WS, " ")
                    .trim();
                }
              }
              sigungu = s;
            }
          }
        }
        if (!isKoreanPeninsula) {
          if (isCountryLike(sido, lowerCountryName, lowerAdminCountry)) sido = "";
          if (isCountryLike(sigungu, lowerCountryName, lowerAdminCountry)) sigungu = "";
          if (isCountryLike(eupmyeon, lowerCountryName, lowerAdminCountry)) eupmyeon = "";
        }
        if (sido && sigungu && sido === sigungu) {
          sigungu = "";
        }
        return { sido, sigungu, eupmyeon };
      },
      parse(data) {
        const gc = (
          data && typeof data === "object" && Array.isArray(data.features)
            ? (data.features[0] || null)
            : null
        )?.properties?.geocoding || null;
        if (!gc) {
          return {
            addr: {
              sido: "",
              sigungu: "",
              eupmyeon: "",
              tag: "",
              fullAddr: "",
            },
          };
        }
        const label = String(gc.label || "");
        const countryCode = String(gc.country_code || "").toLowerCase();
        let firstLabelPart = "";
        let p0 = "";
        let p1 = "";
        if (label) {
          const comma0 = label.indexOf(",");
          if (comma0 === -1) {
            const seg0 = label.trim();
            firstLabelPart = seg0;
            p0 = seg0;
          } else {
            const seg0 = label.slice(0, comma0).trim();
            firstLabelPart = seg0;
            if (seg0) p0 = seg0;
            let start = comma0 + 1;
            while (start < label.length) {
              const comma = label.indexOf(",", start);
              const end = comma === -1 ? label.length : comma;
              const seg = label.slice(start, end).trim();
              if (seg) {
                if (!p0) p0 = seg;
                else { p1 = seg; break; }
              }
              if (comma === -1) break;
              start = comma + 1;
            }
          }
        }
        const { sido, sigungu, eupmyeon } =
          this._getAdminFromGeocoding(gc, countryCode, p0, p1);
        const tagName = gc.name || firstLabelPart || gc.street || gc.city || "";
        const tagType = gc.type || "";
        let tag = tagName;
        if (tagType) tag = tag ? tag + ", " + tagType : tagType;
        const addr = {
          sido,
          sigungu,
          eupmyeon,
          tag,
          fullAddr: label,
        };
        let kind;
        if (countryCode === "kr") kind = "KR";
        else if (countryCode === "kp") kind = "KP";
        else if (countryCode) kind = "WORLD";
        return { addr, kind };
      }
    };
    const AppState = {
      records: [],
      droppedFile: null,
      status: "idle",
      controller: null,
      resumeHandler: null,
      inFlight: false,
      renderReq: null,
      cntSuccess: 0,
      cntFail: 0,
      get isRunning() {
        return (
          this.status === "running" ||
          this.status === "paused" ||
          this.status === "pausing"
        );
      },
      get isBusy() {
        return this.isRunning || this.status === "parsing" || this.status === "stopping";
      },
      get isPaused() {
        return this.status === "paused";
      },
      get isPausing() {
        return this.status === "pausing";
      },
      get isStopping() {
        return this.status === "stopping";
      },
      get processedCount() {
        return this.cntSuccess + this.cntFail;
      },
      reset(status = "idle") {
        this.cntSuccess = 0;
        this.cntFail = 0;
        this.status = status;
        this.controller = null;
        this.resumeHandler = null;
        this.inFlight = false;
        if (this.renderReq !== null) {
          cancelAnimationFrame(this.renderReq);
          this.renderReq = null;
        }
        updateUIState();
        scheduleRender();
      },
      setRecords(newRecords, status = "idle") {
        this.records = newRecords;
        this.reset(status);
      },
      setFile(file) {
        this.droppedFile = file;
      },
      setStatus(st) {
        this.status = st;
        updateUIState();
      },
    };
    const UI_CACHE = {
      parseDisabled: null,
      startDisabled: null,
      pauseDisabled: null,
      resumeDisabled: null,
      stopDisabled: null,
      progActive: null,
      dropZoneInert: null,
    };
    function updateUIState() {
      const s = AppState.status;
      const isBusy = AppState.isBusy;
      if (UI_CACHE.parseDisabled !== isBusy) {
        UI_CACHE.parseDisabled = isBusy;
        parseBtn.disabled = isBusy;
      }
      const startDisabled = isBusy || AppState.records.length === 0;
      if (UI_CACHE.startDisabled !== startDisabled) {
        UI_CACHE.startDisabled = startDisabled;
        startBtn.disabled = startDisabled;
      }
      const pauseDisabled = s !== "running";
      if (UI_CACHE.pauseDisabled !== pauseDisabled) {
        UI_CACHE.pauseDisabled = pauseDisabled;
        pauseBtn.disabled = pauseDisabled;
      }
      const resumeDisabled = s !== "paused";
      if (UI_CACHE.resumeDisabled !== resumeDisabled) {
        UI_CACHE.resumeDisabled = resumeDisabled;
        resumeBtn.disabled = resumeDisabled;
      }
      const stopDisabled = !(AppState.isRunning || s === "parsing") || s === "stopping";
      if (UI_CACHE.stopDisabled !== stopDisabled) {
        UI_CACHE.stopDisabled = stopDisabled;
        stopBtn.disabled = stopDisabled;
      }
      const progActive = s === "running" || s === "pausing";
      if (UI_CACHE.progActive !== progActive) {
        UI_CACHE.progActive = progActive;
        domElements.progShell.classList.toggle("active", progActive);
      }
      if (UI_CACHE.dropZoneInert !== isBusy) {
        UI_CACHE.dropZoneInert = isBusy;
        domElements.dropZone.toggleAttribute("inert", isBusy);
      }
    }
    const STATUS_CACHE = { msg: null, type: null };
    function setStatusMessage(msg, type = "info") {
      const el = domElements.status;
      const nextMsg = String(msg ?? "");
      if (STATUS_CACHE.msg !== nextMsg) {
        STATUS_CACHE.msg = nextMsg;
        el.textContent = nextMsg;
      }
      if (STATUS_CACHE.type !== type) {
        STATUS_CACHE.type = type;
        el.classList.toggle("err", type === "error");
        el.classList.toggle("warn", type === "warn");
        el.classList.toggle("stopped", type === "stopped");
      }
    }
    const EMPTY_HINT_TEXT = {
      init: "random_data.txt 파일을 업로드해 주세요.",
      file: "파일 업로드 완료! 좌표 추출을 눌러주세요.",
      parsing: "좌표를 추출 중입니다.",
      ready: "좌표 추출 완료. 조회 시작을 눌러주세요.",
    };
    function setEmptyHint(kind = "init") {
      domElements.emptyHint.textContent =
        EMPTY_HINT_TEXT[kind] || EMPTY_HINT_TEXT.init;
    }
    function syncFilterEmptyUI(active, totalRows, anyVisible) {
      const wrap = domElements.tableWrap;
      if (active && totalRows > 0) {
        wrap.classList.toggle("filter-empty", !anyVisible);
      } else {
        wrap.classList.remove("filter-empty");
      }
      if (RENDER_CACHE.hasResults) requestScrollShadowSync(wrap);
    }
    const RENDER_CACHE = {
      total: -1,
      success: -1,
      fail: -1,
      remaining: -1,
      pct: -1,
      exportDisabled: null,
      hasResults: null,
      perfMode: null,
    };
    function renderFrame() {
      AppState.renderReq = null;
      const wrap = domElements.tableWrap;
      const tbody = domElements.tbody;
      const total = AppState.records.length;
      const processed = AppState.processedCount;
      const success = AppState.cntSuccess;
      const fail = AppState.cntFail;
      const remaining = total - processed;
      if (RENDER_CACHE.total !== total) {
        RENDER_CACHE.total = total;
        domElements.cntTotal.textContent = fmt(total);
      }
      if (RENDER_CACHE.success !== success) {
        RENDER_CACHE.success = success;
        domElements.cntSuccess.textContent = fmt(success);
      }
      if (RENDER_CACHE.fail !== fail) {
        RENDER_CACHE.fail = fail;
        domElements.cntFail.textContent = fmt(fail);
      }
      if (RENDER_CACHE.remaining !== remaining) {
        RENDER_CACHE.remaining = remaining;
        domElements.cntRemain.textContent = fmt(remaining);
      }
      const pct = total ? Math.round((processed / total) * 100) : 0;
      if (RENDER_CACHE.pct !== pct) {
        RENDER_CACHE.pct = pct;
        domElements.prog.value = pct;
        domElements.progShell.style.setProperty("--pct", pct);
        domElements.progLabel.textContent = `진행 상황 ${pct}%`;
      }
      const exportDisabled = processed === 0;
      if (RENDER_CACHE.exportDisabled !== exportDisabled) {
        RENDER_CACHE.exportDisabled = exportDisabled;
        domElements.exportBtn.disabled = exportDisabled;
      }
      const hasResults = tbody.rows.length > 0;
      if (RENDER_CACHE.hasResults !== hasResults) {
        RENDER_CACHE.hasResults = hasResults;
        wrap.classList.toggle("has-results", hasResults);
        requestScrollShadowSync(wrap);
      }
      const perfMode = total > CONFIG.BIG_MODE_THRESHOLD;
      if (RENDER_CACHE.perfMode !== perfMode) {
        RENDER_CACHE.perfMode = perfMode;
        if (perfMode) root.setAttribute(PERF_MODE_ATTR, "1");
        else root.removeAttribute(PERF_MODE_ATTR);
        syncSpotlightPerfMode(perfMode);
      }
    }
    function scheduleRender() {
      if (AppState.renderReq !== null) return;
      AppState.renderReq = requestAnimationFrame(renderFrame);
    }
    function clearTable() {
      cancelActiveFilterTask();
      clearFindReveals();
      const wrap = domElements.tableWrap;
      if (wrap.scrollTop || wrap.scrollLeft) {
        wrap.scrollTop = 0;
        wrap.scrollLeft = 0;
      }
      resetInteractionState({ closePopover: true });
      domElements.tbody.replaceChildren();
      invalidateRectCache();
      wrap.classList.remove("filter-empty", "has-results");
      RENDER_CACHE.hasResults = false;
      rebindScrollShadowTimeline(wrap);
      requestAnimationFrame(() => {
        if (wrap.scrollTop || wrap.scrollLeft) {
          wrap.scrollTop = 0;
          wrap.scrollLeft = 0;
        }
      });
    }
    function sleep(ms, signal) {
      if (ms <= 0 || signal.aborted) {
        signal.throwIfAborted();
        return Promise.resolve();
      }
      return new Promise((resolve) => {
        let id = 0;
        const onAbort = () => {
          clearTimeout(id);
          resolve();
        };
        id = setTimeout(() => {
          signal.removeEventListener("abort", onAbort);
          resolve();
        }, ms);
        signal.addEventListener("abort", onAbort, EVT_ONCE);
      }).then(() => {
        signal.throwIfAborted();
      });
    }
    const yieldToMain = (() => {
      const y = window.scheduler?.yield;
      if (typeof y === "function") {
        return () => y.call(window.scheduler);
      }
      const channel = new MessageChannel();
      const queue = [];
      let head = 0;
      channel.port1.onmessage = () => {
        if (head >= queue.length) return;
        queue[head++]();
        if (head > 1024 && head * 2 > queue.length) {
          queue.splice(0, head);
          head = 0;
        }
      };
      return () =>
        new Promise((resolve) => {
          queue.push(resolve);
          channel.port2.postMessage(0);
        });
    })();
    async function* lineIterator(stream, signal) {
      const reader = stream
        .pipeThrough(new TextDecoderStream(), { signal })
        .getReader();
      let buffer = "";
      let pendingCR = false;
      let hasCR = false;
      try {
        while (true) {
          const { value: chunk, done } = await reader.read();
          if (done) {
            signal.throwIfAborted();
            if (buffer) yield buffer;
            break;
          }
          if (!hasCR && chunk && chunk.indexOf("\r") !== -1) hasCR = true;
          if (pendingCR) {
            if (chunk && chunk[0] === "\n") {
              buffer += chunk.slice(1);
            } else {
              buffer += chunk;
            }
            pendingCR = false;
          } else {
            buffer += chunk;
          }
          let start = 0;
          if (!hasCR) {
            while (true) {
              const nl = buffer.indexOf("\n", start);
              if (nl === -1) break;
              yield buffer.substring(start, nl);
              start = nl + 1;
            }
            buffer = buffer.substring(start);
            continue;
          }
          while (start < buffer.length) {
            const nl = buffer.indexOf("\n", start);
            const cr = buffer.indexOf("\r", start);
            let pos;
            if (nl === -1) pos = cr;
            else if (cr === -1) pos = nl;
            else pos = nl < cr ? nl : cr;
            if (pos === -1) break;
            yield buffer.substring(start, pos);
            if (buffer[pos] === "\r") {
              if (pos + 1 === buffer.length) {
                pendingCR = true;
                hasCR = true;
                start = pos + 1;
                break;
              }
              start = buffer[pos + 1] === "\n" ? pos + 2 : pos + 1;
            } else {
              start = pos + 1;
            }
          }
          buffer = buffer.substring(start);
        }
      } finally {
        try { await reader.cancel(signal.reason); } catch { /* ignore */ }
        try { reader.releaseLock(); } catch { /* ignore */ }
      }
    }
    async function parseFileToRecords(file, signal) {
      const out = [];
      let nextIdx = 1;
      let lastYield = performance.now();
      let linesSinceYield = 0;
      for await (const line of lineIterator(file.stream(), signal)) {
        signal.throwIfAborted();
        if (++linesSinceYield >= 1000) {
          if (performance.now() - lastYield >= 8) {
            await yieldToMain();
            lastYield = performance.now();
          }
          linesSinceYield = 0;
        }
        if (line.indexOf("위경도") === -1) continue;
        COORD_REGEX.lastIndex = 0;
        for (let m; (m = COORD_REGEX.exec(line));) {
          const lat = m[2];
          const lon = m[3];
          const fLat = +lat;
          const fLon = +lon;
          if (fLat !== fLat || fLon !== fLon) continue;
          if (fLat < -90 || fLat > 90 || fLon < -180 || fLon > 180) continue;
          out.push({
            set: m[1] === "대한민국" ? "KR" : "WORLD",
            idx: nextIdx++,
            _f_kind: undefined,
            _f_sido: "",
            _f_sigungu: "",
            _f_emd: "",
            _f_tag: "",
            _f_fullAddr: "",
            latStr: lat,
            lonStr: lon,
            cacheKey: fLat + "," + fLon,
            lat6: null,
            lon6: null,
            addr: null,
            fullAddr: "",
            _q: null,
          });
        }
      }
      return out;
    }
    const REVERSE_PARSED_CACHE = new Map();
    const REVERSE_PARSED_CACHE_KEYS = [];
    let REVERSE_PARSED_CACHE_HEAD = 0;
    const REVERSE_PARSED_CACHE_MAX = 5_000;
    let LAST_REVERSE_FETCH_AT = 0;
    async function fetchReverseWithRetry(url, userSignal) {
      const maxRetry = CONFIG.MAX_RETRY;
      const timeoutMs = CONFIG.REQUEST_TIMEOUT_MS;
      const baseDelayMs = CONFIG.RATE_LIMIT_DELAY_MS;
      const headers = FETCH_HEADERS;
      const signalAny = AbortSignal.any;
      const signalTimeout = AbortSignal.timeout;
      const anySignals = [userSignal, null];
      let attempt = 0;
      while (++attempt <= maxRetry) {
        userSignal.throwIfAborted();
        let now = performance.now();
        if (LAST_REVERSE_FETCH_AT) {
          const remaining = baseDelayMs - (now - LAST_REVERSE_FETCH_AT);
          if (remaining > 0) {
            await sleep(remaining, userSignal);
            now = performance.now();
          }
        }
        LAST_REVERSE_FETCH_AT = now;
        anySignals[1] = signalTimeout(timeoutMs);
        try {
          const res = await fetch(url, {
            headers,
            signal: signalAny(anySignals),
          });
          if (res.ok) {
            return res.json();
          }
          if (res.status !== 429 && res.status < 500) {
            throw new Error(`HTTP ${res.status}: ${(await res.text()).slice(0, 200)}`);
          }
          if (attempt >= maxRetry) {
            throw new Error(`HTTP ${res.status}: rate limited or server error`);
          }
        } catch (e) {
          userSignal.throwIfAborted();
          if (attempt >= maxRetry) {
            throw e;
          }
        }
        await sleep(baseDelayMs * attempt, userSignal);
      }
    }
    async function runProcessingLoop() {
      const records = AppState.records;
      const startIndex = AppState.processedCount;
      const total = records.length;
      const totalDisp = fmt(total);
      const wrap = domElements.tableWrap;
      const tbody = domElements.tbody;
      const skeletonTemplate = SKELETON_TEMPLATE;
      const rowTemplate = ROW_TEMPLATE;
      const fmtInt = fmt;
      let hasResultsClass = RENDER_CACHE.hasResults ?? wrap.classList.contains("has-results");
      let lastStatusUpdate = 0;
      let lastYield = performance.now();
      const reverseCache = REVERSE_PARSED_CACHE;
      const reverseCacheKeys = REVERSE_PARSED_CACHE_KEYS;
      const baseHref = BASE_URL_HREF;
      let pendingFrag = null;
      let pendingCount = 0;
      const flushPending = () => {
        if (!pendingFrag) return;
        tbody.append(pendingFrag);
        pendingFrag = null;
        pendingCount = 0;
        invalidateRectCache();
        if (wrap.hasAttribute("data-at-top") && wrap.hasAttribute("data-at-bottom")) {
          requestScrollShadowSync(wrap);
        }
      };
      for (let i = startIndex; i < total; i++) {
        const i1 = i + 1;
        let skeletonTr = null;
        let needsFetch = false;
        try {
          if (AppState.isPausing) {
            AppState.setStatus("paused");
            setStatusMessage('일시정지됨. "재개"를 눌러 이어서 진행', "warn");
            const resumeHandler = (AppState.resumeHandler ??= Promise.withResolvers());
            scheduleRender();
            await resumeHandler.promise;
            if (!AppState.isStopping) setStatusMessage("재개합니다…");
          }
          if (!AppState.isRunning) break;
          const r = records[i];
          const cacheKey = r.cacheKey;
          let parsed = reverseCache.get(cacheKey);
          needsFetch = !parsed;
          let signal = null;
          let controller = null;
          if (needsFetch) {
            controller = new AbortController();
            signal = controller.signal;
            flushPending();
            AppState.controller = controller;
            AppState.inFlight = true;
          }
          const tr = (parsed ? rowTemplate : skeletonTemplate).cloneNode(true);
          tr.cells[IDX_COL_INDEX].textContent = "" + i1;
          const mapBtn = tr.cells[MAPS_COL_INDEX].lastElementChild;
          mapBtn.dataset.idx = "" + i;
          const f0 = filterDirty ? getLiveFilterSnapshot() : FILTER_SNAP;
          if (f0.active) {
            tr.setAttribute("hidden", HIDDEN_UNTIL_FOUND);
          }
          const isFirstRow = !hasResultsClass;
          if (isFirstRow) {
            hasResultsClass = true;
            wrap.classList.add("has-results");
            RENDER_CACHE.hasResults = true;
            requestScrollShadowSync(wrap);
            if (f0.active) wrap.classList.add("filter-empty");
          }
          if (needsFetch) {
            tbody.append(tr);
            if (
              (wrap.hasAttribute("data-at-top") &&
                wrap.hasAttribute("data-at-bottom"))
            ) {
              requestScrollShadowSync(wrap);
            }
          } else {
            (pendingFrag ??= document.createDocumentFragment()).append(tr);
            if (++pendingCount >= 200) flushPending();
          }
          skeletonTr = tr;
          let now = 0;
          try {
            if (needsFetch) {
              if (!AppState.isRunning) {
                skeletonTr.remove();
                break;
              }
            }
            if (!AppState.isPaused) {
              now = performance.now();
              if (now - lastStatusUpdate >= 200 || i === startIndex || i1 === total) {
                lastStatusUpdate = now;
                setStatusMessage(`처리 중… (${fmtInt(i1)}/${totalDisp})`);
              }
            }
            if (!parsed) {
              const url = baseHref + "&lat=" + r.latStr + "&lon=" + r.lonStr;
              parsed = AddressFormatter.parse(
                await fetchReverseWithRetry(
                  url,
                  signal
                )
              );
              reverseCache.set(cacheKey, parsed);
              reverseCacheKeys.push(cacheKey);
              if (reverseCacheKeys.length - REVERSE_PARSED_CACHE_HEAD > REVERSE_PARSED_CACHE_MAX) {
                const dropKey = reverseCacheKeys[REVERSE_PARSED_CACHE_HEAD++];
                reverseCache.delete(dropKey);
                if (
                  REVERSE_PARSED_CACHE_HEAD > 1024 &&
                  REVERSE_PARSED_CACHE_HEAD * 2 > reverseCacheKeys.length
                ) {
                  reverseCacheKeys.splice(0, REVERSE_PARSED_CACHE_HEAD);
                  REVERSE_PARSED_CACHE_HEAD = 0;
                }
              }
            }
            const addr = parsed.addr;
            const kind = parsed.kind;
            if (kind) {
              r.set = kind;
              r._f_kind = parsed.kindLower || (parsed.kindLower = kind.toLowerCase());
            } else {
              r._f_kind = r.set === "KR" ? "kr" : r.set === "WORLD" ? "world" : lower(r.set);
            }
            r.addr = addr;
            r.fullAddr = addr.fullAddr;
            let nSido = parsed.nSido;
            if (nSido === undefined) {
              nSido = parsed.nSido = norm(addr.sido);
              parsed.nSigungu = norm(addr.sigungu);
              parsed.nEmd = norm(addr.eupmyeon);
              parsed.nTag = norm(addr.tag);
              parsed.nFullAddr = norm(addr.fullAddr);
            }
            const nSigungu = parsed.nSigungu;
            const nEmd = parsed.nEmd;
            const nTag = parsed.nTag;
            const nFullAddr = parsed.nFullAddr;
            r._f_sido = nSido;
            r._f_sigungu = nSigungu;
            r._f_emd = nEmd;
            r._f_tag = nTag;
            r._f_fullAddr = nFullAddr;
            commitResultRow(skeletonTr, r, wrap, filterDirty ? getLiveFilterSnapshot() : FILTER_SNAP);
          } catch (err) {
            if (AppState.isStopping && err && err.name === "AbortError") {
              skeletonTr.remove();
              break;
            }
            console.error(err);
            const msg = getErrorMessage(err);
            r.set = "에러";
            r.addr = null;
            r.fullAddr = msg;
            r._f_kind = "에러";
            r._f_sido = "";
            r._f_sigungu = "";
            r._f_emd = "";
            r._f_tag = "";
            r._f_fullAddr = norm(msg);
            commitResultRow(skeletonTr, r, wrap, filterDirty ? getLiveFilterSnapshot() : FILTER_SNAP);
            if (!AppState.isStopping)
              setStatusMessage(
                `에러 발생: (${fmtInt(i1)}/${totalDisp}) ${msg}`,
                "error"
              );
          } finally {
            if (!needsFetch) {
              if (!now) now = performance.now();
              if (now - lastYield >= 8) {
                flushPending();
                await yieldToMain();
                lastYield = performance.now();
              }
            }
          }
        } catch (err) {
          console.error(err);
          if (skeletonTr && (skeletonTr.isConnected || skeletonTr.parentNode)) {
            skeletonTr.remove();
          }
          AppState.resumeHandler = null;
          setControlsIdle(`오류로 중단됨: (${fmtInt(i1)}/${totalDisp}) ${getErrorMessage(err)}`, "error");
          break;
        } finally {
          if (needsFetch) {
            AppState.inFlight = false;
            AppState.controller = null;
          }
        }
      }
      flushPending();
      if (AppState.isStopping) {
        setControlsIdle("중지되었습니다.", "stopped");
      } else if (AppState.processedCount >= AppState.records.length) {
        setControlsIdle("모든 처리가 완료되었습니다.");
      }
    }
    function setControlsIdle(message, type = "info") {
      AppState.setStatus("idle");
      setStatusMessage(message, type);
    }
    function getErrorMessage(err) {
      try {
        return String(err?.message || err);
      } catch {
        return "Unknown error";
      }
    }
    function commitResultRow(tr, r, wrap, f) {
      if (!tr) return;
      const connected = tr.isConnected;
      if (!connected && !tr.parentNode) return;
      const cells = tr.cells;
      const latStr = r.latStr;
      const lonStr = r.lonStr;
      cells[KIND_COL_INDEX].textContent = r.set;
      cells[COORDS_COL_INDEX].textContent = latStr + ", " + lonStr;
      const addr = r.addr;
      if (addr) {
        cells[SIDO_COL_INDEX].textContent = addr.sido;
        cells[SIGUNGU_COL_INDEX].textContent = addr.sigungu;
        cells[EMD_COL_INDEX].textContent = addr.eupmyeon;
        cells[TAG_COL_INDEX].textContent = addr.tag;
      } else {
        cells[SIDO_COL_INDEX].textContent =
          cells[SIGUNGU_COL_INDEX].textContent =
          cells[EMD_COL_INDEX].textContent =
          cells[TAG_COL_INDEX].textContent = "";
      }
      cells[FULLADDR_COL_INDEX].textContent = r.fullAddr;
      const td = cells[MAPS_COL_INDEX];
      const btn = td.lastElementChild;
      btn.disabled = false;
      const sk = td.firstElementChild;
      if (sk !== btn) sk.remove();
      const wasHidden = tr.hidden;
      let hidden = false;
      if (f.active) {
        hidden = setHiddenByFilterActiveFn(tr, wasHidden, f, r);
        if (!hidden) wrap.classList.remove("filter-empty");
      } else if (wasHidden) {
        tr.removeAttribute("hidden");
      }
      if (r.set === "에러") AppState.cntFail++;
      else AppState.cntSuccess++;
      scheduleRender();
      if (
        connected &&
        (hidden !== wasHidden ||
          (wrap.hasAttribute("data-at-top") && wrap.hasAttribute("data-at-bottom")))
      ) {
        requestScrollShadowSync(wrap);
      }
    }
    async function handleExport() {
      try {
        const records = AppState.records;
        const totalRows = Math.min(records.length, AppState.processedCount);
        if (totalRows <= 0) {
          return setStatusMessage("내보낼 데이터가 없습니다.", "warn");
        }
        const mapProviderCount = MAP_PROVIDER_COUNT;
        const mapLinks = MAP_LINKS;
        const escCell = csvEsc;
        const hasRound6 = MAP_HAS_ROUND6;
        setStatusMessage("CSV 생성 중…");
        await yieldToMain();
        const parts = [CSV_HEADER_BYTES];
        const totalDisp = fmt(totalRows);
        let chunkLines = [];
        let chunkChars = 0;
        const flushChunk = () => {
          const n = chunkLines.length;
          if (n === 0) return;
          parts.push(CSV_NL_BYTES, CSV_ENCODER.encode(chunkLines.join("\n")));
          chunkChars = 0;
          if (n > 20_000) chunkLines = [];
          else chunkLines.length = 0;
        };
        for (let i = 0; i < totalRows; i++) {
          const r = records[i];
          const lat = r.latStr;
          const lon = r.lonStr;
          const coords = lat + ", " + lon;
          let line =
            escCell(r.set) +
            "," +
            escCell(r.idx) +
            "," +
            escCell(coords) +
            ",";
          const addr = r.addr;
          if (addr) {
            line +=
              escCell(addr.sido) +
              "," +
              escCell(addr.sigungu) +
              "," +
              escCell(addr.eupmyeon) +
              "," +
              escCell(addr.tag) +
              ",";
          } else {
            line += ",,,,";
          }
          line += escCell(r.fullAddr);
          let lat6 = null;
          let lon6 = null;
          if (hasRound6) {
            lat6 = r.lat6;
            if (lat6 == null) r.lat6 = lat6 = fmtCoord6(lat);
            lon6 = r.lon6;
            if (lon6 == null) r.lon6 = lon6 = fmtCoord6(lon);
          }
          for (let k = 0; k < mapProviderCount; k++) {
            line += ',"' + mapLinks[k].build(lat, lon, lat6, lon6) + '"';
          }
          chunkLines.push(line);
          chunkChars += line.length + 1;
          if (chunkChars >= 1_000_000) {
            flushChunk();
            setStatusMessage(`CSV 생성 중… (${fmt(i + 1)}/${totalDisp})`);
            await yieldToMain();
          }
        }
        flushChunk();
        const url = URL.createObjectURL(new Blob(parts, { type: "text/csv;charset=utf-8" }));
        const a = document.createElement("a");
        a.href = url;
        a.download = `${(AppState.droppedFile?.name || "revgeo").replace(RX_FILE_EXT, "")}_${new Date().toISOString().replace(RX_STAMP, "-")}.csv`;
        a.click();
        setTimeout(() => URL.revokeObjectURL(url), 60_000);
        setStatusMessage("CSV 파일을 다운로드했습니다.");
      } catch (err) {
        console.error(err);
        setStatusMessage(`저장 실패: ${getErrorMessage(err)}`, "error");
      }
    }
    async function handleParse() {
      const file = AppState.droppedFile;
      if (!file) return setStatusMessage("파일을 선택해 주세요.", "warn");
      setCoordsText("");
      clearTable();
      AppState.setRecords([], "parsing");
      setEmptyHint("parsing");
      setStatusMessage("파일 분석 중…");
      AppState.controller = new AbortController();
      AppState.inFlight = true;
      try {
        const records = await parseFileToRecords(file, AppState.controller.signal);
        if (!records.length) {
          AppState.setRecords([]);
          return setStatusMessage("좌표를 찾지 못했습니다.", "warn");
        }
        AppState.setRecords(records);
        setEmptyHint("ready");
        const MAX_DISP = 1_000;
        const disp = [];
        for (let i = 0, dispLen = Math.min(records.length, MAX_DISP); i < dispLen; i++) {
          const r = records[i];
          disp.push(`${r.latStr}, ${r.lonStr}`);
        }
        if (records.length > MAX_DISP) {
          disp.push(`... 외 ${fmt(records.length - MAX_DISP)}건 생략됨`);
        }
        setCoordsText(disp.join("\n"));
        setStatusMessage(`분석 완료: ${fmt(records.length)}개 좌표. 조회 시작을 눌러주세요`);
      } catch (err) {
        if (err && err.name === "AbortError") {
          setControlsIdle("중지되었습니다.", "stopped");
          return;
        }
        console.error(err);
        setControlsIdle(`오류 발생: ${getErrorMessage(err)}`, "error");
      } finally {
        AppState.inFlight = false;
        AppState.controller = null;
      }
    }
    domElements.filterQ.addEventListener("input", scheduleApplyFilterAll);
    domElements.filterKind.addEventListener("change", scheduleApplyFilterAll);
    domElements.filterSido.addEventListener("input", scheduleApplyFilterAll);
    domElements.filterSigungu.addEventListener("input", scheduleApplyFilterAll);
    domElements.filterEmd.addEventListener("input", scheduleApplyFilterAll);
    domElements.filterTag.addEventListener("input", scheduleApplyFilterAll);
    domElements.filterFullAddr.addEventListener("input", scheduleApplyFilterAll);
    domElements.tbody.addEventListener("click", (e) => {
      if (!MAP_POPOVER_OPEN) return;
      const btn = e.target?.closest?.("button.map-btn");
      if (!btn || btn === LAST_MAP_INVOKER) return;
      closeMapPopover();
    }, EVT_CAPTURE);
    domElements.tbody.addEventListener(
      "beforematch",
      (e) => {
        const tr = e.target instanceof Element ? e.target.closest("tr") : null;
        if (!tr) return;
        FIND_REVEAL_ACTIVE = true;
        setHiddenByFilterActiveFn = setRowHiddenByFilterActive;
        FIND_REVEALED_ROWS.add(tr);
        if (tr.hidden) tr.removeAttribute("hidden");
        domElements.tableWrap.classList.remove("filter-empty");
        bumpFindRehideTimer();
      }
    );
    const startViewTransition = document.startViewTransition.bind(document);
    const VIEW_TRANSITION_RESULTS_TYPES = ["results"];
    const maybeVT = (fn) => {
      if (domElements.tbody.childElementCount > 0 && !root.hasAttribute(PERF_MODE_ATTR)) {
        const active = document.activeViewTransition;
        if (active) {
          active.types.add("results");
          fn();
          return active;
        }
        return startViewTransition({ update: fn, types: VIEW_TRANSITION_RESULTS_TYPES });
      }
      return fn();
    };
    const COMMANDS = {
      "--parse": () => maybeVT(handleParse),
      "--start": () => maybeVT(() => {
        AppState.reset("running");
        clearTable();
        rebindScrollShadowTimeline(domElements.coords);
        setStatusMessage("조회 시작…");
        void runProcessingLoop().catch((err) => {
          console.error(err);
          AppState.inFlight = false;
          AppState.controller = null;
          AppState.resumeHandler = null;
          setControlsIdle(`오류로 중단됨: ${getErrorMessage(err)}`, "error");
        });
      }),
      "--pause": () => { if (!AppState.isRunning) return; AppState.setStatus("pausing"); if (AppState.inFlight) setStatusMessage("일시정지 요청됨. 현재 작업을 마치고 멈춥니다...", "warn"); },
      "--resume": () => { if (!AppState.isPaused) return; AppState.setStatus("running"); AppState.resumeHandler?.resolve(); AppState.resumeHandler = null; },
      "--stop": () => {
        if (!(AppState.isRunning || AppState.status === "parsing")) return;
        AppState.setStatus("stopping");
        rebindScrollShadowTimeline(domElements.tableWrap);
        rebindScrollShadowTimeline(domElements.coords);
        AppState.resumeHandler?.resolve();
        AppState.resumeHandler = null;
        if (AppState.controller) {
          AppState.controller.abort();
          setStatusMessage("중지 요청됨. 취소 중…", "warn");
        } else {
          setStatusMessage("중지 요청됨. 정리 중…", "warn");
        }
      },
      "--export": handleExport,
      "--filter-clear": () => {
        domElements.filtersForm.reset();
        filterDirty = true;
        cancelActiveFilterTask();
        clearFindReveals();
        startChunkedFilterApply(getLiveFilterSnapshot());
      },
    };
    function handleCommandError(err) {
      if (err?.name === "AbortError") return;
      console.error(err);
      setStatusMessage(`명령 실행 중 오류: ${getErrorMessage(err)}`, "error");
    }
    domElements.app.addEventListener("command", (e) => {
      const cmd = COMMANDS[e.command];
      if (!cmd) return;
      try {
        const ret = cmd();
        const then = ret && ret.then;
        if (typeof then === "function") {
          then.call(ret, null, handleCommandError);
        }
      } catch (err) {
        handleCommandError(err);
      }
    });
    domElements.filtersForm.addEventListener("submit", (e) => e.preventDefault());
    function handleFile(file) {
      if (!file) return;
      domElements.file.value = "";
      if (!file.name.toLowerCase().endsWith(".txt") && file.type !== "text/plain") {
        setStatusMessage("텍스트 파일(.txt)만 업로드 가능합니다.", "warn");
        return;
      }
      if (AppState.isBusy) {
        setStatusMessage("조회/파싱 중에는 파일을 변경할 수 없습니다. 중지 후 다시 선택해 주세요.", "warn");
        return;
      }
      setCoordsText("");
      clearTable();
      AppState.setRecords([]);
      REVERSE_PARSED_CACHE.clear();
      REVERSE_PARSED_CACHE_KEYS.length = 0;
      REVERSE_PARSED_CACHE_HEAD = 0;
      AppState.setFile(file);
      setEmptyHint("file");
      setStatusMessage(`파일 선택됨: ${file.name}  →  좌표 추출을 눌러주세요`);
      for (const el of DROP_ZONE_FILE_LABELS) {
        const strong = document.createElement("strong");
        strong.textContent = file.name;
        el.replaceChildren("선택된 파일: ", strong);
      }
    }
    domElements.file.addEventListener("change", () =>
      maybeVT(() => handleFile(domElements.file.files?.[0] || null))
    );
    domElements.dropZone.addEventListener("dragover", (e) => e.preventDefault());
    domElements.dropZone.addEventListener("drop", (e) => {
      e.preventDefault();
      maybeVT(() => handleFile(e.dataTransfer.files?.[0] || null));
    });
    document.addEventListener("scroll", (e) => {
      if (MAP_POPOVER_OPEN) closeMapPopover();
      if (!SCROLL_ACTIVE) {
        if (FIND_REVEAL_ACTIVE) bumpFindRehideTimer();
        setGlobalScrolling(true);
      }
      SCROLL_ACTIVE = true;
      SCROLL_LAST_TS = performance.now();
      if (!SCROLL_IDLE_RAF) SCROLL_IDLE_RAF = requestAnimationFrame(checkScrollIdle);
    }, EVT_CAPTURE_PASSIVE);
    const rectCache = new Map();
    let rectCacheDirty = false;
    let pointerRaf = null;
    let pointerX = 0;
    let pointerY = 0;
    let pointerTarget = null;
    let lastPointerTarget = null;
    let hasPointer = false;
    const tableWrap = domElements.tableWrap;
    const tableCardStack = tableWrap.closest(".card-stack");
    const tableCardStackSpotlight = tableCardStack.querySelector(".card-stack-spotlight");
    const docBody = document.body;
    const SPOTLIGHT_OBSERVED_NODES = document.querySelectorAll(
      ".card, .card-stack-spotlight"
    );
    let stackSpotlightSuppressed = false;
    const clearPointerState = () => {
      hasPointer = false;
      lastPointerTarget = null;
      pointerTarget = null;
      if (stackSpotlightSuppressed) {
        stackSpotlightSuppressed = false;
        tableCardStackSpotlight.classList.remove("suppressed");
      }
      if (pointerRaf !== null) {
        cancelAnimationFrame(pointerRaf);
        pointerRaf = null;
      }
    };
    function resetInteractionState({ closePopover = false } = {}) {
      resetScrollState();
      clearPointerState();
      if (closePopover && MAP_POPOVER_OPEN) closeMapPopover();
    }
    let DEACTIVATE_QUEUED = false;
    let NEED_CLOSE_POPOVER = false;
    function requestDeactivate({ closePopover = false } = {}) {
      NEED_CLOSE_POPOVER ||= closePopover;
      if (DEACTIVATE_QUEUED) return;
      DEACTIVATE_QUEUED = true;
      queueMicrotask(() => {
        DEACTIVATE_QUEUED = false;
        resetInteractionState({ closePopover: NEED_CLOSE_POPOVER });
        NEED_CLOSE_POPOVER = false;
      });
    }
    window.addEventListener("blur", () => requestDeactivate());
    window.addEventListener("pagehide", () => {
      resetInteractionState({ closePopover: true });
    });
    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState === "hidden") {
        requestDeactivate({ closePopover: true });
      }
    });
    const invalidateRectCache = () => {
      rectCacheDirty = true;
    };
    const requestRectCacheRefresh = () => {
      if (pointerRaf !== null) return;
      if (!hasPointer || SCROLL_ACTIVE) return;
      let target = lastPointerTarget;
      if (target && !target.isConnected) target = null;
      if (!target) {
        target = document.elementFromPoint(pointerX, pointerY);
      }
      if (!target) return;
      pointerTarget = target;
      pointerRaf = requestAnimationFrame(flushPointer);
    };
    const setStackSpotlightSuppressed = (suppressed) => {
      if (stackSpotlightSuppressed === suppressed) return;
      stackSpotlightSuppressed = suppressed;
      tableCardStackSpotlight.classList.toggle("suppressed", suppressed);
      if (!suppressed) {
        lastPointerTarget = null;
        pointerTarget = null;
        requestRectCacheRefresh();
      }
    };
    let resizeScrollResetTimer = null;
    let SPOTLIGHT_EFFECTS_ENABLED = false;
    let rectCacheObserver = null;
    const handlePointerOut = (e) => {
      if (e.relatedTarget == null) clearPointerState();
    };
    const handleTablePointerEnter = () => setStackSpotlightSuppressed(true);
    const handleTablePointerLeave = () => setStackSpotlightSuppressed(false);
    const handleWindowResize = () => {
      invalidateRectCache();
      syncLayoutMetrics();
      if (resizeScrollResetTimer) clearTimeout(resizeScrollResetTimer);
      resizeScrollResetTimer = setTimeout(() => {
        resizeScrollResetTimer = null;
        resetScrollState();
      }, 150);
      requestRectCacheRefresh();
    };
    function syncSpotlightPerfMode(perfMode) {
      if (perfMode) {
        if (!SPOTLIGHT_EFFECTS_ENABLED) return;
        SPOTLIGHT_EFFECTS_ENABLED = false;
        window.removeEventListener("scroll", invalidateRectCache, EVT_CAPTURE_PASSIVE);
        window.removeEventListener("resize", handleWindowResize);
        document.removeEventListener("pointerout", handlePointerOut, EVT_CAPTURE);
        document.removeEventListener("pointercancel", clearPointerState);
        document.removeEventListener("pointermove", handlePointerMove);
        document.removeEventListener("pointerdown", handlePointerDownSpotlight, EVT_CAPTURE);
        tableWrap.removeEventListener("pointerenter", handleTablePointerEnter);
        tableWrap.removeEventListener("pointerleave", handleTablePointerLeave);
        tableWrap.removeEventListener("pointercancel", handleTablePointerLeave);
        rectCacheObserver.disconnect();
        rectCacheObserver = null;
        if (resizeScrollResetTimer) {
          clearTimeout(resizeScrollResetTimer);
          resizeScrollResetTimer = null;
        }
        clearPointerState();
        invalidateRectCache();
        return;
      }
      if (SPOTLIGHT_EFFECTS_ENABLED) return;
      if (root.hasAttribute(PERF_MODE_ATTR)) return;
      SPOTLIGHT_EFFECTS_ENABLED = true;
      window.addEventListener("scroll", invalidateRectCache, EVT_CAPTURE_PASSIVE);
      window.addEventListener("resize", handleWindowResize);
      document.addEventListener("pointerout", handlePointerOut, EVT_CAPTURE);
      document.addEventListener("pointercancel", clearPointerState);
      document.addEventListener("pointermove", handlePointerMove);
      document.addEventListener("pointerdown", handlePointerDownSpotlight, EVT_CAPTURE);
      tableWrap.addEventListener("pointerenter", handleTablePointerEnter);
      tableWrap.addEventListener("pointerleave", handleTablePointerLeave);
      tableWrap.addEventListener("pointercancel", handleTablePointerLeave);
      rectCacheObserver = new ResizeObserver(
        syncSpotlightPerfMode._resizeObserverCallback ||
        (syncSpotlightPerfMode._resizeObserverCallback = () => {
          invalidateRectCache();
          requestRectCacheRefresh();
          syncLayoutMetrics();
        })
      );
      for (const node of SPOTLIGHT_OBSERVED_NODES) {
        rectCacheObserver.observe(node);
      }
      rectCacheObserver.observe(tbl.tHead);
      requestRectCacheRefresh();
    }
    const flushPointer = () => {
      pointerRaf = null;
      const target = pointerTarget;
      pointerTarget = null;
      if (!target || SCROLL_ACTIVE) return;
      lastPointerTarget = target;
      updateSpotlightsFromTarget(target, pointerX, pointerY);
    };
    function handlePointerMove(e) {
      const pt = e.pointerType;
      if (pt && pt !== "mouse") return;
      if (SCROLL_ACTIVE) return;
      pointerX = e.clientX;
      pointerY = e.clientY;
      let target = e.target;
      if (target && target.nodeType !== 1) target = target.parentElement;
      pointerTarget = target;
      hasPointer = true;
      if (pointerRaf !== null) return;
      pointerRaf = requestAnimationFrame(flushPointer);
    }
    function setSpotlightVars(el, clientX, clientY) {
      if (rectCacheDirty) {
        rectCacheDirty = false;
        rectCache.clear();
      }
      let rect = rectCache.get(el);
      if (!rect) {
        rect = el.getBoundingClientRect();
        rectCache.set(el, rect);
      }
      el.style.setProperty("--mouse-x", (clientX - rect.left) + "px");
      el.style.setProperty("--mouse-y", (clientY - rect.top) + "px");
    }
    function updateSpotlightsFromTarget(target, x, y) {
      const isTableTarget = tableWrap.contains(target);
      if (isTableTarget !== stackSpotlightSuppressed) {
        setStackSpotlightSuppressed(isTableTarget);
      }
      let btn = null;
      let card = null;
      let current = target;
      while (current && current !== docBody) {
        if (!btn && current.tagName === "BUTTON") btn = current;
        if (!card && current.classList.contains("card")) card = current;
        if (btn && card) break;
        current = current.parentElement;
      }
      if (btn) setSpotlightVars(btn, x, y);
      if (stackSpotlightSuppressed) return;
      if (tableCardStack.contains(target)) {
        setSpotlightVars(tableCardStackSpotlight, x, y);
        return;
      }
      if (card && !card.classList.contains("no-spotlight")) {
        setSpotlightVars(card, x, y);
      }
    }
    function handlePointerDownSpotlight(e) {
      if (SCROLL_ACTIVE) return;
      let t = e.target;
      if (t && t.nodeType !== 1) t = t.parentElement;
      if (!t) return;
      const x = e.clientX;
      const y = e.clientY;
      pointerX = x;
      pointerY = y;
      lastPointerTarget = t;
      hasPointer = true;
      updateSpotlightsFromTarget(t, x, y);
    }
    syncSpotlightPerfMode(root.hasAttribute(PERF_MODE_ATTR));
  </script>
</body>

</html>